<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø–ª–∏—Ç–∫–∏ Zero-–±–ª–æ–∫</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background: #f5f5f5;
            /* height: 100vh; */ /* —É–±—Ä–∞—Ç—å */
            /* overflow: hidden; */ /* —É–±—Ä–∞—Ç—å */
        }
        
        .tcalc-container {
            max-width: 1200px;
            margin: 0 auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
            /* height: 100vh; */ /* —É–±—Ä–∞—Ç—å */
            display: flex;
            flex-direction: column;
        }
        
        .tcalc-header {
            background: linear-gradient(135deg, #333333 0%, #555555 100%);
            color: #fff;
            padding: 30px;
            text-align: left;
        }
        
        .tcalc-header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 18px;
            position: relative;
        }
        .tcalc-header-logo {
            flex: 0 0 auto;
        }
        .tcalc-header-title {
            flex: 1 1 0;
            text-align: center;
        }
        .tcalc-header-spacer {
            flex: 0 0 auto;
            width: 54px;
            height: 1px;
            /* –¥–ª—è —Å–∏–º–º–µ—Ç—Ä–∏–∏ —Å –ª–æ–≥–æ—Ç–∏–ø–æ–º */
        }
        
        .tcalc-header h1 {
            margin: 0 0 10px 0;
            font-size: 28px;
            font-weight: 700;
        }
        
        .tcalc-header p {
            margin: 0;
            opacity: 0.9;
            font-size: 16px;
        }
        
        .tcalc-content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 0;
            flex: 1;
            overflow: hidden;
        }
        
        .tcalc-sidebar {
            background: #f8f9fa;
            padding: 15px;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }
        
        .tcalc-main {
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .tcalc-section {
            margin-bottom: 15px;
        }
        
        .tcalc-section h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333333;
            font-weight: 600;
        }
        
        .tcalc-upload {
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fff;
        }
        
        .tcalc-upload:hover {
            border-color: #ff6600;
            background: #fff8f0;
        }
        
        .tcalc-upload input[type="file"] {
            display: none;
        }
        
        .tcalc-upload-icon {
            font-size: 24px;
            color: #6c757d;
            margin-bottom: 10px;
        }
        
        .tcalc-tools {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .tcalc-tool-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 14px;
        }
        
        .tcalc-tool-btn:hover {
            border-color: #ff6600;
            box-shadow: 0 2px 8px rgba(255,102,0,0.15);
        }
        
        .tcalc-tool-btn.active {
            border-color: #ff6600;
            background: #fff8f0;
            color: #ff6600;
        }
        
        .tcalc-tool-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
        
        .tcalc-tile-palette {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .tcalc-tile-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tcalc-tile-option:hover {
            border-color: #ff6600;
            box-shadow: 0 2px 8px rgba(255,102,0,0.15);
        }
        
        .tcalc-tile-option.active {
            border-color: #ff6600;
            background: #fff8f0;
        }
        
        .tcalc-tile-preview {
            width: 40px;
            height: 30px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            background: linear-gradient(45deg, #a52a2a 25%, transparent 25%), 
                        linear-gradient(-45deg, #a52a2a 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #a52a2a 75%), 
                        linear-gradient(-45deg, transparent 75%, #a52a2a 75%);
            background-size: 4px 4px;
            background-position: 0 0, 0 2px, 2px -2px, -2px 0px;
        }
        
        .tcalc-tile-info {
            flex: 1;
        }
        
        .tcalc-tile-name {
            font-weight: 600;
            color: #333333;
            font-size: 14px;
        }
        
        .tcalc-tile-size {
            font-size: 12px;
            color: #6c757d;
        }
        
        .tcalc-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .tcalc-edit-tools {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            padding: 12px;
            background: #fff;
            border: 1px solid #e9ecef;
            border-radius: 8px;
        }
        
        .tcalc-edit-tools h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #2c3e50;
        }
        
        .tcalc-edit-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .tcalc-btn-small {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tcalc-btn-small:hover {
            transform: translateY(-1px);
        }
        
        .tcalc-color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .tcalc-color-picker input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .tcalc-stats {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .tcalc-stats h4 {
            margin: 0 0 10px 0;
            color: #2d5a2d;
            font-size: 14px;
        }
        
        .tcalc-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 12px;
        }
        
        .tcalc-stat-item {
            display: flex;
            justify-content: space-between;
        }
        
        .tcalc-stat-label {
            color: #555;
        }
        
        .tcalc-stat-value {
            font-weight: 600;
            color: #2d5a2d;
        }
        
        .tcalc-btn {
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .tcalc-btn-primary {
            background: #ff6600;
            color: #fff;
        }
        
        .tcalc-btn-primary:hover {
            background: #e55a00;
        }
        
        .tcalc-btn-secondary {
            background: #6c757d;
            color: #fff;
        }
        
        .tcalc-btn-secondary:hover {
            background: #545b62;
        }
        
        .tcalc-btn-danger {
            background: #dc3545;
            color: #fff;
        }
        
        .tcalc-btn-danger:hover {
            background: #c82333;
        }
        
        .tcalc-btn-success {
            background: #333333;
            color: #fff;
        }
        
        .tcalc-btn-success:hover {
            background: #555555;
        }
        
        .tcalc-btn:disabled {
            background: #6c757d !important;
            color: #fff !important;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .tcalc-canvas-container {
            flex: 1;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
            background: #f8f9fa;
            position: relative;
            min-height: 400px;
            max-height: 500px;
        }
        
        .tcalc-size-menu {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #ff6600;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            min-width: 200px;
            max-width: 300px;
            min-height: 180px;
            max-height: 400px;
            display: none;
            cursor: move;
            user-select: none;
            resize: none;
            overflow: hidden;
        }
        
        .tcalc-size-menu-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 15px;
            height: 15px;
            background: #ff6600;
            border-radius: 0 0 0 8px;
            cursor: nw-resize;
            z-index: 1002;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: white;
            font-weight: bold;
        }
        
        .tcalc-size-menu-resize-handle:hover {
            background: #e55a00;
        }
        
        .tcalc-size-menu h4 {
            margin: 0 0 12px 0;
            color: #333333;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            position: relative;
        }
        
        .tcalc-size-menu-close {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #ff6600;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #ff6600;
            font-weight: bold;
            z-index: 1003;
            transition: all 0.2s ease;
        }
        
        .tcalc-size-menu-close:hover {
            background: #ff6600;
            color: #fff;
        }
        
        .tcalc-size-menu-delete {
            position: absolute;
            top: 20px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #dc3545;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #dc3545;
            font-weight: bold;
            z-index: 1003;
            transition: all 0.2s ease;
        }
        
        .tcalc-size-menu-delete:hover {
            background: #dc3545;
            color: #fff;
        }
        
        .tcalc-size-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 6px;
            /* –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –≤—Å–µ –≥—Ä—É–ø–ø—ã –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É */
            width: 100%;
            min-width: 0;
            justify-content: space-between;
        }
        
        .tcalc-size-label {
            font-size: 12px;
            color: #555;
            font-weight: 600;
            min-width: 60px;
            /* –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –≤—Å–µ –º–µ—Ç–∫–∏ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—É—é —à–∏—Ä–∏–Ω—É */
            flex-shrink: 0;
            flex: 0 0 60px;
        }
        
        .tcalc-size-input {
            flex: 0 0 80px;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
            /* –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –≤—Å–µ –ø–æ–ª—è –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä */
            min-width: 60px;
            max-width: 80px;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .tcalc-size-input[readonly] {
            background-color: #f8f9fa;
            color: #6c757d;
            cursor: default;
            /* –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ readonly –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä */
            width: auto;
            min-width: 0;
            max-width: none;
        }
        
        .tcalc-size-input:focus {
            outline: none;
            border-color: #ff6600;
            box-shadow: 0 0 0 2px rgba(255,102,0,0.2);
        }
        
        .tcalc-size-axis {
            font-size: 10px;
            color: #888;
            font-style: italic;
            /* –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –≤—Å–µ –æ—Å–∏ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—É—é —à–∏—Ä–∏–Ω—É */
            flex-shrink: 0;
            min-width: 35px;
            flex: 0 0 35px;
            text-align: right;
        }
        
        .tcalc-size-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .tcalc-size-btn {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tcalc-size-btn-apply {
            background: #ff6600;
            color: #fff;
        }
        
        .tcalc-size-btn-apply:hover {
            background: #e55a00;
        }
        
        .tcalc-size-btn-cancel {
            background: #6c757d;
            color: #fff;
        }
        
        .tcalc-size-btn-cancel:hover {
            background: #545b62;
        }
        
        .tcalc-zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 5px;
            z-index: 1000;
        }
        
        .tcalc-zoom-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #dee2e6;
            background: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .tcalc-zoom-btn:hover {
            background: #f8f9fa;
            border-color: #007bff;
        }
        
        .tcalc-zoom-level {
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            min-width: 45px;
            text-align: center;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }
        
        .tcalc-zoom-level:hover {
            background-color: #f8f9fa;
        }
        
        .tcalc-zoom-input {
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            min-width: 45px;
            text-align: center;
            border: 1px solid #007bff;
            border-radius: 3px;
            padding: 2px 4px;
            background: #fff;
            outline: none;
        }
        
        .tcalc-rotation-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ff6600;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 600;
            color: #ff6600;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .tcalc-cursor-angle {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            z-index: 10000;
            display: none;
            white-space: nowrap;
        }
        
        .tcalc-canvas {
            width: 100%;
            height: 100%;
        }
        
        .tcalc-results {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .tcalc-results h3 {
            margin: 0 0 15px 0;
            color: #333333;
            font-size: 18px;
        }
        
        .tcalc-tile-counts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .tcalc-count-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #fff;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        
        .tcalc-count-label {
            font-weight: 600;
            color: #333333;
        }
        
        .tcalc-count-value {
            font-size: 18px;
            font-weight: 700;
            color: #ff6600;
        }
        
        .tcalc-total {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, #333333 0%, #555555 100%);
            color: #fff;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 700;
        }
        
        .tcalc-instructions {
            background: #fff8f0;
            border: 1px solid #ffcc99;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .tcalc-instructions h4 {
            margin: 0 0 8px 0;
            color: #ff6600;
            font-size: 14px;
        }
        
        .tcalc-instructions ol {
            margin: 0;
            padding-left: 16px;
            color: #424242;
            font-size: 12px;
        }
        
        .tcalc-instructions li {
            margin-bottom: 6px;
        }
        
        .tcalc-status {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #856404;
        }
        
        .tcalc-progress {
            background: #fff8f0;
            border: 1px solid #ffcc99;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .tcalc-progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .tcalc-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ff9933);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .tcalc-progress-text {
            font-size: 12px;
            color: #ff6600;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .tcalc-content {
                grid-template-columns: 1fr;
            }
            
            .tcalc-sidebar {
                border-right: none;
                border-bottom: 1px solid #e9ecef;
            }
            
            .tcalc-tile-counts {
                grid-template-columns: 1fr;
            }
        }
        
        /* –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –∫ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä—É –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ —è–∫–æ—Ä—è */
        html:target {
            scroll-margin-top: 20px;
        }
        
        #tcalc-calculator:target {
            scroll-margin-top: 20px;
        }
        
        .tcalc-watermark {
            pointer-events: none;
            position: absolute;
            inset: 0;
            z-index: 10;
            opacity: 1;
            background-image: url('data:image/svg+xml;utf8,<svg width="240" height="240" xmlns="http://www.w3.org/2000/svg"><text x="0" y="120" font-size="38" fill="black" fill-opacity="0.13" transform="rotate(-30 60 120)" font-family="Arial">Plitochka.by</text></svg>');
            background-repeat: repeat;
            background-size: 240px 240px;
        }
        
        .tool-section {
            background: #f8f9fa;
            padding: 12px;
            margin-top: 15px;
            border-radius: 8px;
        }
        .tool-section h4 {
            margin: 0 0 10px 0;
            color: #2d3436;
        }
        /* .tcalc-tool-btn.active[data-tool="polygon"] {
            background: #0984e3;
            color: white;
        } */
    </style>
</head>
<body>
    <div class="tcalc-container" id="tcalc-calculator">
        <div class="tcalc-header" id="tcalc-header">
            <div class="tcalc-header-content">
                <div class="tcalc-header-logo">
                    <img src="https://raw.githubusercontent.com/PashaDe/tcalc-js/main/logoplit.png" alt="–õ–æ–≥–æ—Ç–∏–ø" style="height: 54px; width: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); background: #fff; filter: brightness(1.7) grayscale(0.2);" loading="lazy">
                </div>
                <div class="tcalc-header-title">
                    <h1 style="margin-bottom: 6px;">–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø–ª–∏—Ç–∫–∏ "–ù–æ–≤—ã–π –≥–æ—Ä–æ–¥"</h1>
                    <p style="margin: 0; opacity: 0.9; font-size: 16px;">–ù–∞—Ä–∏—Å—É–π—Ç–µ –≥—Ä–∞–Ω–∏—Ü—ã —É—á–∞—Å—Ç–∫–∞ –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–ª–∏—Ç–∫–æ–π</p>
                </div>
                <div class="tcalc-header-spacer"></div>
            </div>
        </div>
        
        <div class="tcalc-content">
            <div class="tcalc-sidebar">
                <div class="tcalc-section">
                    <h3>–ó–∞–≥—Ä—É–∑–∫–∞ –ø–ª–∞–Ω–∞</h3>
                    <div class="tcalc-upload" onclick="document.getElementById('tcalc-plan-upload').click()">
                        <div class="tcalc-upload-icon">
                            <svg width="32" height="32" viewBox="0 0 32 32" style="transform: rotate(180deg);" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M16 4 L28 16 H24 V28 H8 V16 H4 Z" fill="#ff6600" stroke="#d2b48c" stroke-width="2"/>
                                <rect x="12" y="20" width="8" height="8" fill="#fff" stroke="#d2b48c" stroke-width="1.5"/>
                            </svg>
                        </div>
                        <div>–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–ª–∞–Ω —É—á–∞—Å—Ç–∫–∞</div>
                        <div style="font-size: 12px; color: #6c757d; margin-top: 5px;">JPG, PNG –¥–æ 5MB</div>
                    </div>
                    <input type="file" id="tcalc-plan-upload" accept="image/*" onchange="loadPlan(event)">
                </div>
                
                <div class="tcalc-section">
                    <h3>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–∏—Å–æ–≤–∞–Ω–∏—è</h3>
                    <div class="tcalc-tools">
                        <div class="tcalc-tool-btn active" data-tool="ruler" onclick="selectTool('ruler')">
                            <div class="tcalc-tool-icon">‚¨ú</div>
                            <div>–ü–ª–æ—â–∞–¥–∫–∞ (–ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫)</div>
                        </div>
                        <div class="tcalc-tool-btn" data-tool="eraser" onclick="selectTool('eraser')">
                            <div class="tcalc-tool-icon">‚ùå</div>
                            <div>–õ–∞—Å—Ç–∏–∫ (—É–¥–∞–ª–µ–Ω–∏–µ)</div>
                        </div>
                        <div class="tcalc-tool-btn" data-tool="polygon" onclick="selectTool('polygon')">
                            <div class="tcalc-tool-icon">üî∑</div>
                            <div>–ü–æ–ª–∏–≥–æ–Ω</div>
                        </div>
                    </div>
                    <div class="tcalc-status" id="tcalc-status">
                        –í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∏ –Ω–∞—Ä–∏—Å—É–π—Ç–µ –≥—Ä–∞–Ω–∏—Ü—ã —É—á–∞—Å—Ç–∫–∞
                    </div>
                    <div class="tcalc-progress" id="tcalc-progress" style="display: none;">
                        <div class="tcalc-progress-bar">
                            <div class="tcalc-progress-fill" id="tcalc-progress-fill"></div>
                        </div>
                        <div class="tcalc-progress-text" id="tcalc-progress-text">–ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —É—á–∞—Å—Ç–∫–∞...</div>
                    </div>
                </div>
                
                <div class="tcalc-section">
                    <h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —É—á–∞—Å—Ç–∫–∞</h3>
                    <div class="tcalc-stats">
                        <h4>–ü–ª–æ—â–∞–¥—å –∏ —Ä–∞–∑–º–µ—Ä—ã:</h4>
                        <div class="tcalc-stats-grid">
                            <div class="tcalc-stat-item">
                                <span class="tcalc-stat-label">–ü–ª–æ—â–∞–¥—å —É—á–∞—Å—Ç–∫–∞:</span>
                                <span class="tcalc-stat-value" id="tcalc-area">0 –º¬≤</span>
                            </div>
                            <div class="tcalc-stat-item">
                                <span class="tcalc-stat-label">–ü–µ—Ä–∏–º–µ—Ç—Ä:</span>
                                <span class="tcalc-stat-value" id="tcalc-perimeter">0 –º</span>
                            </div>
                            <div class="tcalc-stat-item">
                                <span class="tcalc-stat-label">–î–ª–∏–Ω–∞ —É—á–∞—Å—Ç–∫–∞:</span>
                                <span class="tcalc-stat-value" id="tcalc-length">0 –º</span>
                            </div>
                            <div class="tcalc-stat-item">
                                <span class="tcalc-stat-label">–®–∏—Ä–∏–Ω–∞ —É—á–∞—Å—Ç–∫–∞:</span>
                                <span class="tcalc-stat-value" id="tcalc-width">0 –º</span>
                            </div>
                            <div class="tcalc-stat-item">
                                <span class="tcalc-stat-label">–î–ª–∏–Ω–∞ —Å –ø–ª–∏—Ç–∫–æ–π:</span>
                                <span class="tcalc-stat-value" id="tcalc-tiles-length">0 –º</span>
                            </div>
                            <div class="tcalc-stat-item">
                                <span class="tcalc-stat-label">–®–∏—Ä–∏–Ω–∞ —Å –ø–ª–∏—Ç–∫–æ–π:</span>
                                <span class="tcalc-stat-value" id="tcalc-tiles-width">0 –º</span>
                            </div>
                        </div>
                        <div id="polygon-stats" style="display:none; margin-top:10px; background:#e8f5e8; border-radius:8px; padding:10px; color:#0984e3; font-weight:600;">
                            <div id="polygon-current-line" style="display:none;">–¢–µ–∫—É—â–∞—è –ª–∏–Ω–∏—è: <span id="polygon-current-line-value">0.00</span> –º</div>
                            <div id="polygon-perimeter" style="display:none;">–ü–µ—Ä–∏–º–µ—Ç—Ä: <span id="polygon-perimeter-value">0.00</span> –º</div>
                            <div id="polygon-area-info" style="display:none;">–ü–ª–æ—â–∞–¥—å –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ–ª–∏–≥–æ–Ω–∞: <span id="polygon-area-value">0.00</span> –º¬≤</div>
                            <div id="polygon-angle" style="display:none;">–£–≥–æ–ª –Ω–∞–∫–ª–æ–Ω–∞: <span id="polygon-angle-value">0.0</span>¬∞</div>
                        </div>
                    </div>
                </div>
                
                <div class="tcalc-section">
                    <h3>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
                    <div class="tcalc-controls">
                        <button class="tcalc-btn tcalc-btn-success" onclick="fillAreaWithTiles()">–ó–∞–ø–æ–ª–Ω–∏—Ç—å —É—á–∞—Å—Ç–æ–∫ –ø–ª–∏—Ç–∫–æ–π</button>
                        <button class="tcalc-btn tcalc-btn-primary" onclick="clearTiles()">–û—á–∏—Å—Ç–∏—Ç—å –ø–ª–∏—Ç–∫–∏</button>
                        <button class="tcalc-btn tcalc-btn-secondary" onclick="clearCanvas()">–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
                        <button class="tcalc-btn tcalc-btn-secondary" onclick="exportResults()">–≠–∫—Å–ø–æ—Ä—Ç PDF</button>
                        <button class="tcalc-btn tcalc-btn-secondary" onclick="saveProject()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                        <button class="tcalc-btn tcalc-btn-secondary" onclick="loadProject()">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                    </div>
                </div>
            </div>
            
            <div class="tcalc-main">
                                    <div class="tcalc-instructions">
                        <h4>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</h4>
                        <ol>
                            <li>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –ø–ª–∞–Ω —É—á–∞—Å—Ç–∫–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</li>
                            <li>–í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: "–õ–∏–Ω–µ–π–∫–∞" –¥–ª—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –∏–ª–∏ "–ö–∞—Ä–∞–Ω–¥–∞—à" –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –æ—Ç —Ä—É–∫–∏</li>
                            <li>–ù–∞—Ä–∏—Å—É–π—Ç–µ –≥—Ä–∞–Ω–∏—Ü—ã —É—á–∞—Å—Ç–∫–∞ –Ω–∞ –ø–ª–∞–Ω–µ</li>
                            <li>–ù–∞–∂–º–∏—Ç–µ "–ó–∞–ø–æ–ª–Ω–∏—Ç—å —É—á–∞—Å—Ç–æ–∫ –ø–ª–∏—Ç–∫–æ–π" –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ–º–∏ —Ä–∞–∑–º–µ—Ä–∞–º–∏</li>
                        </ol>
                    </div>
                
                <div class="tcalc-canvas-container">
                    <div class="tcalc-watermark"></div>
                    <div class="tcalc-zoom-controls">
                        <button class="tcalc-zoom-btn" onclick="zoomIn()" title="–ü—Ä–∏–±–ª–∏–∑–∏—Ç—å">+</button>
                        <span class="tcalc-zoom-level" id="tcalc-zoom-level" onclick="enableZoomInput()" title="–ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –≤–≤–æ–¥–∞ –º–∞—Å—à—Ç–∞–±–∞">100%</span>
                        <button class="tcalc-zoom-btn" onclick="zoomOut()" title="–û—Ç–¥–∞–ª–∏—Ç—å">‚àí</button>
                        <button class="tcalc-zoom-btn" onclick="resetZoom()" title="–°–±—Ä–æ—Å–∏—Ç—å –º–∞—Å—à—Ç–∞–±">‚ü≤</button>
                    </div>
                    
                    <div class="tcalc-rotation-indicator" id="tcalc-rotation-indicator">
                        –£–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞: <span id="tcalc-rotation-angle">0¬∞</span>
                    </div>
                    
                    <div class="tcalc-cursor-angle" id="tcalc-cursor-angle">
                        –£–≥–æ–ª: <span id="tcalc-cursor-angle-value">0¬∞</span>
                    </div>
                    
                    <div class="tcalc-size-menu" id="tcalc-size-menu">
                        <h4>–í–≤–µ–¥–∏—Ç–µ —Ä–∞–∑–º–µ—Ä—ã –ø–ª–æ—â–∞–¥–∫–∏</h4>
                        <div class="tcalc-size-menu-close" onclick="hideSizeMenu()" title="–ó–∞–∫—Ä—ã—Ç—å –º–µ–Ω—é">√ó</div>
                        <div class="tcalc-size-menu-delete" onclick="deleteCurrentBoundary()" title="–£–¥–∞–ª–∏—Ç—å –ø–ª–æ—â–∞–¥–∫—É">√ó</div>
                        <div class="tcalc-size-input-group">
                            <span class="tcalc-size-label">–¥–ª–∏–Ω–∞</span>
                            <input type="number" class="tcalc-size-input" id="tcalc-length-input" step="0.01" min="0.1" max="100">
                            <span class="tcalc-size-axis">(–æ—Å—å Y)</span>
                        </div>
                        <div class="tcalc-size-input-group">
                            <span class="tcalc-size-label">—à–∏—Ä–∏–Ω–∞</span>
                            <input type="number" class="tcalc-size-input" id="tcalc-width-input" step="0.01" min="0.1" max="100">
                            <span class="tcalc-size-axis">(–æ—Å—å X)</span>
                        </div>
                        <div class="tcalc-size-input-group">
                            <span class="tcalc-size-label">–ø–ª–æ—â–∞–¥—å</span>
                            <input type="number" class="tcalc-size-input" id="tcalc-area-input" readonly step="0.01">
                            <span class="tcalc-size-axis">(–º¬≤)</span>
                        </div>
                        <div class="tcalc-size-buttons">
                            <button class="tcalc-size-btn tcalc-size-btn-apply" onclick="applySizeToBoundary()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
                            <button class="tcalc-size-btn tcalc-size-btn-cancel" onclick="hideSizeMenu()">–û—Ç–º–µ–Ω–∞</button>
                        </div>
                        <div class="tcalc-size-menu-resize-handle" title="–ò–∑–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä">‚Üñ</div>
                    </div>
                    
                    <canvas id="tcalc-canvas" class="tcalc-canvas"></canvas>
                </div>
                
                <div class="tcalc-results">
                    <h3>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—á–µ—Ç–∞</h3>
                    <div class="tcalc-tile-counts">
                        <div class="tcalc-count-item">
                            <span class="tcalc-count-label">–ë–æ–ª—å—à–∞—è –ø–ª–∏—Ç–∫–∞ (330√ó220):</span>
                            <span class="tcalc-count-value" id="tcalc-count-large">0</span>
                        </div>
                        <div class="tcalc-count-item">
                            <span class="tcalc-count-label">–°—Ä–µ–¥–Ω—è—è –ø–ª–∏—Ç–∫–∞ (220√ó220):</span>
                            <span class="tcalc-count-value" id="tcalc-count-medium">0</span>
                        </div>
                        <div class="tcalc-count-item">
                            <span class="tcalc-count-label">–ú–∞–ª–∞—è –ø–ª–∏—Ç–∫–∞ (110√ó220):</span>
                            <span class="tcalc-count-value" id="tcalc-count-small">0</span>
                        </div>
                    </div>
                    <div class="tcalc-total">
                        –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–∏—Ç–æ–∫: <span id="tcalc-total-count">0</span>
                    </div>
                </div>
                <div style="margin-top: 24px; text-align: center;">
                    <img src="https://raw.githubusercontent.com/PashaDe/tcalc-js/main/plitochkaBy.png" alt="Plitochka.by –±—Ä–µ–Ω–¥" style="max-width: 120px; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 4px;" loading="lazy">
                    <div style="font-size: 11px; color: #bbb; margin-top: 1px;">by Plitochka.by</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const TILE_CONFIG = {
            'large': { 
                width: 3.3,
                height: 2.2,
                name: '–ë–æ–ª—å—à–∞—è',
                price: 250 
            },
            'medium': { 
                width: 2.2,
                height: 2.2,
                name: '–°—Ä–µ–¥–Ω—è—è',
                price: 200 
            },
            'small': { 
                width: 1.1,
                height: 2.2,
                name: '–ú–∞–ª–∞—è',
                price: 150 
            }
        };

        const TILE_GRADIENT = 'linear-gradient(135deg, #ffffff 0%, #cccccc 100%)';

        let canvas;
        let currentTool = 'ruler';
        let currentTileType = 'mixed';
        let isDrawing = false;
        let startPoint = null;
        let drawingPath = [];
        let tileCounts = {
            'large': 0,
            'medium': 0,
            'small': 0
        };
        
        let currentTileColor = '#a52a2a';
        
        let currentZoom = 1;
        let isPanning = false;
        let lastPanPoint = null;
        
        let currentEditingBoundary = null;
        
        let isSizeMenuDragging = false;
        let sizeMenuDragStart = null;
        let sizeMenuOriginalPosition = null;
        
        let isSizeMenuResizing = false;
        let sizeMenuResizeStart = null;
        let sizeMenuOriginalSize = null;

        function snapToGrid(value) {
            return Math.round(value / 1.1) * 1.1;
        }

        function getBoundaryBounds(boundary) {
            if (boundary.type === 'rect') {
                const currentWidth = boundary.width * (boundary.scaleX || 1);
                const currentHeight = boundary.height * (boundary.scaleY || 1);
                
                if (boundary.angle && Math.abs(boundary.angle) > 0.1) {
                    const center = boundary.getCenterPoint();
                    const angle = boundary.angle * Math.PI / 180;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    const halfWidth = currentWidth / 2;
                    const halfHeight = currentHeight / 2;
                    
                    const corners = [
                        { x: -halfWidth, y: -halfHeight },
                        { x: halfWidth, y: -halfHeight },
                        { x: halfWidth, y: halfHeight },
                        { x: -halfWidth, y: halfHeight }
                    ];
                    
                    const rotatedCorners = corners.map(corner => ({
                        x: center.x + corner.x * cos - corner.y * sin,
                        y: center.y + corner.x * sin + corner.y * cos
                    }));
                    
                    const xs = rotatedCorners.map(c => c.x);
                    const ys = rotatedCorners.map(c => c.y);
                    
                    return {
                        left: Math.min(...xs),
                        top: Math.min(...ys),
                        right: Math.max(...xs),
                        bottom: Math.max(...ys),
                        rotated: true,
                        angle: boundary.angle,
                        center: center,
                        corners: rotatedCorners,
                        originalWidth: currentWidth,
                        originalHeight: currentHeight
                    };
                } else {
                    return {
                        left: boundary.left,
                        top: boundary.top,
                        right: boundary.left + currentWidth,
                        bottom: boundary.top + currentHeight,
                        rotated: false
                    };
                }
            } else if (boundary.type === 'polygon' && boundary.data && boundary.data.type === 'polygon-boundary') {
                // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã Fabric.js –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                const points = boundary.points || boundary._points;
                if (points && points.length > 0) {
                    // –ü–æ–ª—É—á–∞–µ–º —Ç–æ—á–∫–∏ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö —á–µ—Ä–µ–∑ –º–µ—Ç–æ–¥ getCoords
                    const coords = boundary.getCoords();
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                    const xs = coords.map(p => p.x);
                    const ys = coords.map(p => p.y);
                    
                    return {
                        left: Math.min(...xs),
                        top: Math.min(...ys),
                        right: Math.max(...xs),
                        bottom: Math.max(...ys),
                        rotated: false,
                        polygon: true,
                        points: coords,
                        center: boundary.getCenterPoint(),
                        angle: boundary.angle || 0
                    };
                }
            }
            return null;
        }

        function isTileInBoundary(tile, boundaryBounds) {
            if (!boundaryBounds) return false;
            
            if (boundaryBounds.polygon) {
                // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —É–≥–ª—ã –ø–ª–∏—Ç–∫–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
                const tileCorners = [
                    { x: tile.left, y: tile.top },
                    { x: tile.left + tile.width, y: tile.top },
                    { x: tile.left + tile.width, y: tile.top + tile.height },
                    { x: tile.left, y: tile.top + tile.height }
                ];
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —É–≥–ª—ã –ø–ª–∏—Ç–∫–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
                for (let corner of tileCorners) {
                    if (!isPointInPolygon(corner, boundaryBounds.points)) {
                        return false;
                    }
                }
                return true;
            } else if (!boundaryBounds.rotated) {
                const tileLeft = tile.left;
                const tileTop = tile.top;
                const tileRight = tile.left + tile.width;
                const tileBottom = tile.top + tile.height;
                
                return tileLeft >= boundaryBounds.left && 
                       tileTop >= boundaryBounds.top && 
                       tileRight <= boundaryBounds.right && 
                       tileBottom <= boundaryBounds.bottom;
            } else {
                const tileCenter = {
                    x: tile.left + tile.width / 2,
                    y: tile.top + tile.height / 2
                };
                
                return isPointInRotatedRectangle(tileCenter, boundaryBounds);
            }
        }
        
        function isPointInRotatedRectangle(point, bounds) {
            if (!bounds.rotated || !bounds.center) return false;
            
            const angle = -bounds.angle * Math.PI / 180;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            const dx = point.x - bounds.center.x;
            const dy = point.y - bounds.center.y;
            
            const rotatedX = dx * cos - dy * sin;
            const rotatedY = dx * sin + dy * cos;
            
            const halfWidth = bounds.originalWidth / 2;
            const halfHeight = bounds.originalHeight / 2;
            
            return Math.abs(rotatedX) <= halfWidth && Math.abs(rotatedY) <= halfHeight;
        }
        
        function isPointInPolygon(point, polygonPoints) {
            if (!polygonPoints || polygonPoints.length < 3) return false;
            
            let inside = false;
            const x = point.x;
            const y = point.y;
            
            for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {
                const xi = polygonPoints[i].x;
                const yi = polygonPoints[i].y;
                const xj = polygonPoints[j].x;
                const yj = polygonPoints[j].y;
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }
        
        function calculatePolygonAngle(points) {
            if (!points || points.length < 2) return 0;
            
            // –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—É—é –¥–ª–∏–Ω–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É –ø–æ–ª–∏–≥–æ–Ω–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            let maxLength = 0;
            let mainAngle = 0;
            
            for (let i = 0; i < points.length; i++) {
                const nextIndex = (i + 1) % points.length;
                const dx = points[nextIndex].x - points[i].x;
                const dy = points[nextIndex].y - points[i].y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length > maxLength) {
                    maxLength = length;
                    mainAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                }
            }
            
            return mainAngle;
        }
        
        function zoomIn() {
            if (currentZoom < 7) {
                const oldZoom = currentZoom;
                currentZoom *= 1.2;
                
                canvas.setZoom(currentZoom);
                
                let centerX, centerY;
                
                if (canvas.lastMouseEvent) {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —ç–∫—Ä–∞–Ω–∞ –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                    const mouseX = canvas.lastMouseEvent.clientX;
                    const mouseY = canvas.lastMouseEvent.clientY;
                    const canvasRect = canvas.wrapperEl.getBoundingClientRect();
                    centerX = mouseX - canvasRect.left;
                    centerY = mouseY - canvasRect.top;
                } else {
                    centerX = canvas.getWidth() / 2;
                    centerY = canvas.getHeight() / 2;
                }
                
                const vpt = canvas.viewportTransform;
                const zoomRatio = currentZoom / oldZoom;
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é viewport –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –∫—É—Ä—Å–æ—Ä–µ
                const newVpt4 = centerX - (centerX - vpt[4]) * zoomRatio;
                const newVpt5 = centerY - (centerY - vpt[5]) * zoomRatio;
                
                vpt[4] = newVpt4;
                vpt[5] = newVpt5;
                
                updateZoom();
            }
        }
        
        function zoomOut() {
            if (currentZoom > 1) {
                const oldZoom = currentZoom;
                currentZoom /= 1.2;
                
                canvas.setZoom(currentZoom);
                
                let centerX, centerY;
                
                if (canvas.lastMouseEvent) {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —ç–∫—Ä–∞–Ω–∞ –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                    const mouseX = canvas.lastMouseEvent.clientX;
                    const mouseY = canvas.lastMouseEvent.clientY;
                    const canvasRect = canvas.wrapperEl.getBoundingClientRect();
                    centerX = mouseX - canvasRect.left;
                    centerY = mouseY - canvasRect.top;
                } else {
                    centerX = canvas.getWidth() / 2;
                    centerY = canvas.getHeight() / 2;
                }
                
                const vpt = canvas.viewportTransform;
                const zoomRatio = currentZoom / oldZoom;
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é viewport –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –∫—É—Ä—Å–æ—Ä–µ
                const newVpt4 = centerX - (centerX - vpt[4]) * zoomRatio;
                const newVpt5 = centerY - (centerY - vpt[5]) * zoomRatio;
                
                vpt[4] = newVpt4;
                vpt[5] = newVpt5;
                
                updateZoom();
            }
        }
        
        function resetZoom() {
            const oldZoom = currentZoom;
            currentZoom = 1;
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞—Å—à—Ç–∞–± 100%
            canvas.setZoom(1);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ –º–∞—Å—à—Ç–∞–±–∞
            const vpt = canvas.viewportTransform;
            if (canvas.lastMouseEvent) {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —ç–∫—Ä–∞–Ω–∞ –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                const mouseX = canvas.lastMouseEvent.clientX;
                const mouseY = canvas.lastMouseEvent.clientY;
                const canvasRect = canvas.wrapperEl.getBoundingClientRect();
                const centerX = mouseX - canvasRect.left;
                const centerY = mouseY - canvasRect.top;
                const zoomRatio = currentZoom / oldZoom;
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é viewport –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
                const newVpt4 = centerX - (centerX - vpt[4]) * zoomRatio;
                const newVpt5 = centerY - (centerY - vpt[5]) * zoomRatio;
                
                vpt[4] = newVpt4;
                vpt[5] = newVpt5;
            } else {
                // –ï—Å–ª–∏ –∫—É—Ä—Å–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω, —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ canvas
                vpt[4] = 0;
                vpt[5] = 0;
            }
            
            canvas.setViewportTransform(vpt);
            updateZoom();
        }
        
        function updateZoom() {
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Å—à—Ç–∞–± canvas
            canvas.setZoom(currentZoom);
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º viewport transform
            canvas.setViewportTransform(canvas.viewportTransform);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è –º–∞—Å—à—Ç–∞–±–∞
            const zoomLevelElement = document.getElementById('tcalc-zoom-level');
            if (zoomLevelElement && !zoomLevelElement.classList.contains('tcalc-zoom-input')) {
                zoomLevelElement.textContent = Math.round(currentZoom * 100) + '%';
            }
            
            // –í–∫–ª—é—á–∞–µ–º/–≤—ã–∫–ª—é—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
            if (currentZoom > 1) {
                enablePanning();
            } else {
                disablePanning();
            }
            
            canvas.renderAll();
        }
        
        function enablePanning() {
            if (currentTool !== 'eraser') {
                canvas.defaultCursor = 'grab';
            }
            canvas.selection = false;
        }
        
        function disablePanning() {
            if (currentTool === 'ruler') {
                canvas.defaultCursor = 'crosshair';
            } else if (currentTool === 'eraser') {
                canvas.defaultCursor = 'pointer';
            } else {
                canvas.defaultCursor = 'default';
            }
            canvas.selection = currentTool !== 'eraser';
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
            isPanning = false;
            lastPanPoint = null;
        }
        


        document.addEventListener('DOMContentLoaded', function() {
            initCanvas();
            updateResults();
            initSizeMenuDragging();
            
            if (window.location.hash) {
                const hash = window.location.hash.substring(1);
                if (hash === 'tcalc-calculator' || hash === 'calculator' || hash === 'tcalc') {
                    const calculator = document.getElementById('tcalc-calculator');
                    if (calculator) {
                        setTimeout(() => {
                            calculator.scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'start' 
                            });
                        }, 100);
                    }
                }
            }
        });

        function initCanvas() {
            canvas = new fabric.Canvas('tcalc-canvas', {
                backgroundColor: '#f8f9fa',
                selection: false,
                preserveObjectStacking: true
            });
            const container = document.querySelector('.tcalc-canvas-container');
            canvas.setWidth(container.offsetWidth);
            canvas.setHeight(500);
            window.addEventListener('resize', function() {
                canvas.setWidth(container.offsetWidth);
                canvas.renderAll();
            });
            // === –í–ê–ñ–ù–û: –¥–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ ===
            canvas.on('mouse:down', onMouseDown);
            canvas.on('mouse:move', onMouseMove);
            canvas.on('mouse:up', onMouseUp);
            // –£–¥–∞–ª–µ–Ω–æ: canvas.on('object:modified', onObjectModified); - –∑–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã—à–µ
            canvas.on('object:moving', onObjectMoving);
            canvas.on('object:scaling', onObjectScaling);
            canvas.on('object:rotating', onObjectRotating);
            canvas.on('selection:created', onSelectionCreated);
            canvas.on('selection:cleared', onSelectionCleared);
            canvas.on('mouse:wheel', onMouseWheel);
            canvas.on('mouse:dblclick', onMouseDoubleClick);
            
            // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–ª–∏–≥–æ–Ω–æ–≤
            canvas.on('object:modified', function(e) {
                if (e.target && e.target.data && e.target.data.type === 'polygon-boundary') {
                    // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–ª–æ—â–∞–¥—å –∏ —Ä–∞–∑–º–µ—Ä—ã –ø–æ–ª–∏–≥–æ–Ω–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏
                    const points = e.target.points || e.target._points;
                    if (points && points.length > 2) {
                        const area = calculatePolygonArea(points);
                        const dimensions = calculatePolygonDimensions(points);
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª–∏–≥–æ–Ω–∞
                        e.target.data.area = area;
                        e.target.data.width = dimensions.width;
                        e.target.data.height = dimensions.height;
                        
                        console.log('–ü–æ–ª–∏–≥–æ–Ω –∏–∑–º–µ–Ω–µ–Ω - –Ω–æ–≤–∞—è –ø–ª–æ—â–∞–¥—å:', area, '—Ä–∞–∑–º–µ—Ä—ã:', dimensions);
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é —Ä–∞–∑–º–µ—Ä–æ–≤
                        showSizeMenu(e.target);
                        updateStatistics();
                    }
                }
                // –í—ã–∑—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
                onObjectModified(e);
            });
            canvas.on('mouse:down', function(e) {
                if (e.e.button === 2) {
                    canvas.discardActiveObject();
                    hideSizeMenu();
                    canvas.renderAll();
                    e.e.preventDefault();
                }
            });
            canvas.on('mouse:move', function(e) {
                canvas.lastMouseEvent = e.e;
            });
            canvas.wrapperEl.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
            let isWrapperPanning = false;
            let lastWrapperPanPoint = null;
            let isPanningInProgress = false;
            
            canvas.wrapperEl.addEventListener('mousedown', function(e) {
                if (e.button === 2 && currentZoom > 1) {
                    e.preventDefault();
                    isWrapperPanning = true;
                    isPanningInProgress = true;
                    lastWrapperPanPoint = { x: e.clientX, y: e.clientY };
                    canvas.defaultCursor = 'grabbing';
                    
                    canvas.getObjects().forEach(obj => {
                        if (obj.data && obj.data.type === 'tile') {
                            obj.visible = false;
                        }
                    });
                    canvas.renderAll();
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isWrapperPanning && lastWrapperPanPoint && (e.buttons & 2)) {
                    const currentPoint = { x: e.clientX, y: e.clientY };
                    const deltaX = currentPoint.x - lastWrapperPanPoint.x;
                    const deltaY = currentPoint.y - lastWrapperPanPoint.y;
                    
                    const panSpeed = currentZoom;
                    const adjustedDeltaX = deltaX * panSpeed;
                    const adjustedDeltaY = deltaY * panSpeed;
                    
                    const vpt = canvas.viewportTransform;
                    const newX = vpt[4] + adjustedDeltaX;
                    const newY = vpt[5] + adjustedDeltaY;
                    
                    const canvasWidth = canvas.getWidth();
                    const canvasHeight = canvas.getHeight();
                    const maxX = 0;
                    const minX = -(canvasWidth * currentZoom - canvasWidth);
                    const maxY = 0;
                    const minY = -(canvasHeight * currentZoom - canvasHeight);
                    
                    vpt[4] = Math.max(minX, Math.min(maxX, newX));
                    vpt[5] = Math.max(minY, Math.min(maxY, newY));
                    
                    canvas.setViewportTransform(vpt);
                    lastWrapperPanPoint = currentPoint;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                if (isWrapperPanning && e.button === 2) {
                    isWrapperPanning = false;
                    lastWrapperPanPoint = null;
                    canvas.defaultCursor = 'grab';
                    
                    if (isPanningInProgress) {
                        canvas.getObjects().forEach(obj => {
                            if (obj.data && obj.data.type === 'tile') {
                                obj.visible = true;
                            }
                        });
                        canvas.renderAll();
                        isPanningInProgress = false;
                    }
                }
            });
        }

        function selectTool(tool) {
            currentTool = tool;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
            if (drawingPath && drawingPath.length > 0) {
                // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ–ª–∏–≥–æ–Ω–∞
                const tempElements = canvas.getObjects().filter(obj =>
                    obj.data && (obj.data.type === 'polygon-temp-line' || obj.data.type === 'polygon-line' || obj.data.type === 'polygon-point')
                );
                tempElements.forEach(element => canvas.remove(element));
                drawingPath = [];
                canvas.renderAll();
            }
            
            document.querySelectorAll('.tcalc-tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            
            const status = document.getElementById('tcalc-status');
            if (tool === 'ruler') {
                status.textContent = '–ù–∞—Ä–∏—Å—É–π—Ç–µ –ø–ª–æ—â–∞–¥–∫—É –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø–ª–∏—Ç–∫–æ–π';
            } else if (tool === 'eraser') {
                status.textContent = '–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –æ–±—ä–µ–∫—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è';
            } else if (tool === 'polygon') {
                status.textContent = '–ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—á–µ–∫ –ø–æ–ª–∏–≥–æ–Ω–∞. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –∏–ª–∏ –∫–ª–∏–∫ –ø–æ –ø–µ—Ä–≤–æ–π —Ç–æ—á–∫–µ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.';
            }
            
            if (tool === 'ruler') {
                canvas.defaultCursor = 'crosshair';
            } else if (tool === 'eraser') {
                canvas.defaultCursor = 'pointer';
                canvas.selection = false;
            } else if (tool === 'polygon') {
                canvas.defaultCursor = 'crosshair';
                canvas.selection = false;
            } else {
                canvas.defaultCursor = 'default';
                canvas.selection = true;
            }
        }

        function loadPlan(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                fabric.Image.fromURL(e.target.result, function(img) {
                    // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–¥ —Ä–∞–∑–º–µ—Ä canvas
                    const canvasWidth = canvas.getWidth();
                    const canvasHeight = canvas.getHeight();
                    
                    const scaleX = canvasWidth / img.width;
                    const scaleY = canvasHeight / img.height;
                    const scale = Math.min(scaleX, scaleY);
                    
                    img.scale(scale);
                    img.set({
                        left: (canvasWidth - img.width * scale) / 2,
                        top: (canvasHeight - img.height * scale) / 2
                    });
                    
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                });
            };
            reader.readAsDataURL(file);
        }

        function onMouseDown(e) {
            if (e.e.button === 2) {
                // –ï—Å–ª–∏ —Ä–∏—Å—É–µ—Ç—Å—è –ø–æ–ª–∏–≥–æ–Ω, –æ—Ç–º–µ–Ω—è–µ–º –µ–≥–æ
                if (currentTool === 'polygon' && drawingPath && drawingPath.length > 0) {
                    // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ–ª–∏–≥–æ–Ω–∞
                    const tempElements = canvas.getObjects().filter(obj =>
                        obj.data && (obj.data.type === 'polygon-temp-line' || obj.data.type === 'polygon-line' || obj.data.type === 'polygon-point')
                    );
                    tempElements.forEach(element => canvas.remove(element));
                    drawingPath = [];
                    canvas.renderAll();
                    
                    // –°–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é
                    hideSizeMenu();
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
                    const status = document.getElementById('tcalc-status');
                    status.textContent = '–†–∏—Å–æ–≤–∞–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ. –ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–≥–æ –ø–æ–ª–∏–≥–æ–Ω–∞.';
                    return;
                }
                
                if (canvas.getActiveObject()) {
                    canvas.discardActiveObject();
                    hideSizeMenu();
                    canvas.renderAll();
                    return;
                }
                return;
            }
            
            if (e.e.button === 0) {
                if (currentTool === 'eraser') {
                    if (e.target) {
                        if (e.target.data && e.target.data.type === 'boundary') {
                            const boundary = e.target;
                            const boundaryBounds = getBoundaryBounds(boundary);
                            
                            const tiles = canvas.getObjects().filter(obj => 
                                obj.data && obj.data.type === 'tile' && 
                                isTileInBoundary(obj, boundaryBounds)
                            );
                            tiles.forEach(tile => canvas.remove(tile));
                            
                            canvas.remove(boundary);
                            
                            if (currentEditingBoundary === boundary) {
                                hideSizeMenu();
                            }
                        } else if (e.target.data && e.target.data.type === 'polygon-boundary') {
                            const polygon = e.target;
                            const boundaryBounds = getBoundaryBounds(polygon);
                            
                            const tiles = canvas.getObjects().filter(obj => 
                                obj.data && obj.data.type === 'tile' && 
                                isTileInBoundary(obj, boundaryBounds)
                            );
                            tiles.forEach(tile => canvas.remove(tile));
                            
                            canvas.remove(polygon);
                            
                            if (currentEditingBoundary === polygon) {
                                hideSizeMenu();
                            }
                        } else if (e.target.data && e.target.data.type === 'tile') {
                            canvas.remove(e.target);
                        }
                        
                        canvas.renderAll();
                        updateResults();
                        updateStatistics();
                    }
                    return;
                }
                
                if (e.target && e.target.data && (e.target.data.type === 'boundary' || e.target.data.type === 'polygon-boundary')) {
                    currentEditingBoundary = e.target;
                    showSizeMenu(e.target);
                    return;
                }
                
                if (e.target) return;
                
                isDrawing = true;
                const pointer = canvas.getPointer(e.e);
                
                if (currentTool === 'ruler') {
                    startPoint = { x: pointer.x, y: pointer.y };
                    isDrawing = true;
                } else if (currentTool === 'polygon') {
                    // –ù–∞—á–∏–Ω–∞–µ–º —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–∞
                    if (!drawingPath || drawingPath.length === 0) {
                        drawingPath = [];
                        const snappedX = snapToGrid(pointer.x);
                        const snappedY = snapToGrid(pointer.y);
                        drawingPath.push({ x: snappedX, y: snappedY });
                        startPoint = { x: snappedX, y: snappedY };
                        isDrawing = true;
                        
                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –±–æ–∫–æ–≤–æ–µ –º–µ–Ω—é —Å—Ä–∞–∑—É –ø—Ä–∏ –Ω–∞—á–∞–ª–µ —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ø–æ–ª–∏–≥–æ–Ω–∞
                        document.getElementById('tcalc-size-menu').style.display = 'block';
                        document.getElementById('polygon-current-line').style.display = '';
                        document.getElementById('polygon-current-line').textContent = '0.00 –º';
                        document.getElementById('polygon-area-info').style.display = 'none';
                        document.getElementById('polygon-stats').style.display = 'none';
                        document.getElementById('polygon-perimeter').style.display = 'none';
                        
                        // –û—á–∏—â–∞–µ–º –ø–æ–ª—è –≤–≤–æ–¥–∞
                        document.getElementById('tcalc-length-input').value = '';
                        document.getElementById('tcalc-width-input').value = '';
                        document.getElementById('tcalc-area-input').value = '';
                        
                        // –†–∏—Å—É–µ–º –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É
                        const circle = new fabric.Circle({
                            left: snappedX - 3,
                            top: snappedY - 3,
                            radius: 3,
                            fill: '#00b894',
                            selectable: false,
                            data: { type: 'polygon-point' }
                        });
                        canvas.add(circle);
                        canvas.renderAll();
                    } else {
                        // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É –∫ –ø–æ–ª–∏–≥–æ–Ω—É
                        const snappedX = snapToGrid(pointer.x);
                        const snappedY = snapToGrid(pointer.y);
                        drawingPath.push({ x: snappedX, y: snappedY });
                        // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ç–æ—á–∫–∏ (–ø—É–Ω–∫—Ç–∏—Ä–Ω–∞—è)
                        if (drawingPath.length > 1) {
                            const prevPoint = drawingPath[drawingPath.length - 2];
                            const line = new fabric.Line([prevPoint.x, prevPoint.y, snappedX, snappedY], {
                                stroke: '#0984e3',
                                strokeWidth: 2,
                                strokeDashArray: [6, 4],
                                selectable: false,
                                data: { type: 'polygon-line' }
                            });
                            canvas.add(line);
                        }
                        // –†–∏—Å—É–µ–º —Ç–æ—á–∫—É
                        const circle = new fabric.Circle({
                            left: snappedX - 3,
                            top: snappedY - 3,
                            radius: 3,
                            fill: '#00b894',
                            selectable: false,
                            data: { type: 'polygon-point' }
                        });
                        canvas.add(circle);
                        canvas.renderAll();
                    }
                }
            }
        }

        function onMouseMove(e) {
            if (isPanning && lastPanPoint && (e.e.buttons & 2)) {
                return;
            }
            
            if (!isDrawing) return;
            
            const pointer = canvas.getPointer(e.e);
            
            if (currentTool === 'ruler') {
                let activeObject = canvas.getActiveObject();
                
                if (!activeObject || !activeObject.data || activeObject.data.type !== 'boundary') {
                    const distance = Math.sqrt(
                        Math.pow(pointer.x - startPoint.x, 2) + 
                        Math.pow(pointer.y - startPoint.y, 2)
                    );
                    
                    if (distance > 5) {
                        const snappedX = snapToGrid(startPoint.x);
                        const snappedY = snapToGrid(startPoint.y);
                        
                        const rect = new fabric.Rect({
                            left: snappedX,
                            top: snappedY,
                            width: 1.1,
                            height: 2.2,
                            fill: 'rgba(255, 102, 0, 0.1)',
                            stroke: '#ff6600',
                            strokeWidth: 0.1,
                            selectable: true,
                            data: { type: 'boundary' }
                        });
                        canvas.add(rect);
                        canvas.setActiveObject(rect);
                        
                        currentEditingBoundary = rect;
                        activeObject = rect;
                    }
                }
                
                if (activeObject && activeObject.type === 'rect' && activeObject.data && activeObject.data.type === 'boundary') {
                    const snappedX = snapToGrid(pointer.x);
                    const snappedY = snapToGrid(pointer.y);
                    
                    const startX = activeObject.left;
                    const startY = activeObject.top;
                    
                    let newLeft, newTop, newWidth, newHeight;
                    
                    if (snappedX >= startX) {
                        newLeft = startX;
                        newWidth = snappedX - startX;
                    } else {
                        newLeft = snappedX;
                        newWidth = startX - snappedX;
                    }
                    
                    if (snappedY >= startY) {
                        newTop = startY;
                        newHeight = snappedY - startY;
                    } else {
                        newTop = snappedY;
                        newHeight = startY - snappedY;
                    }
                    
                    newWidth = Math.max(newWidth, 1.1);
                    newHeight = Math.max(newHeight, 2.2);
                    
                    activeObject.set({
                        left: newLeft,
                        top: newTop,
                        width: newWidth,
                        height: newHeight
                    });
                }
            } else if (currentTool === 'polygon' && drawingPath && drawingPath.length > 0) {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –ª–∏–Ω–∏—é –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏ –¥–æ –∫—É—Ä—Å–æ—Ä–∞
                const lastPoint = drawingPath[drawingPath.length - 1];
                const snappedX = snapToGrid(pointer.x);
                const snappedY = snapToGrid(pointer.y);
                // –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –≤—Ä–µ–º–µ–Ω–Ω—É—é –ª–∏–Ω–∏—é
                const tempLines = canvas.getObjects().filter(obj =>
                    obj.data && obj.data.type === 'polygon-temp-line'
                );
                tempLines.forEach(line => canvas.remove(line));
                // –†–∏—Å—É–µ–º –Ω–æ–≤—É—é –≤—Ä–µ–º–µ–Ω–Ω—É—é –ª–∏–Ω–∏—é
                const tempLine = new fabric.Line([lastPoint.x, lastPoint.y, snappedX, snappedY], {
                    stroke: '#0984e3',
                    strokeWidth: 2,
                    strokeDashArray: [6, 4],
                    selectable: false,
                    data: { type: 'polygon-temp-line' }
                });
                canvas.add(tempLine);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –¥–ª–∏–Ω—É —Ç–µ–∫—É—â–µ–π –ª–∏–Ω–∏–∏ –≤ –±–æ–∫–æ–≤–æ–º –º–µ–Ω—é
                const lineLength = Math.sqrt(Math.pow(snappedX - lastPoint.x, 2) + Math.pow(snappedY - lastPoint.y, 2)) / 10; // –≤ –º–µ—Ç—Ä–∞—Ö
                document.getElementById('polygon-current-line').style.display = '';
                document.getElementById('polygon-current-line').textContent = lineLength.toFixed(2) + ' –º';
                
                canvas.renderAll();
            }
            
            canvas.renderAll();
        }

        function onMouseUp(e) {
            if (isPanning && e.e.button === 2) {
                return;
            }
            
            if (isDrawing && currentTool === 'ruler') {
                const activeObject = canvas.getActiveObject();
                if (activeObject && activeObject.type === 'rect' && activeObject.data && activeObject.data.type === 'boundary') {
                    setTimeout(() => {
                        showSizeMenu(activeObject);
                    }, 100);
                } else {
                    isDrawing = false;
                    startPoint = null;
                }
            }
            
            if (currentEditingBoundary && currentEditingBoundary.data && currentEditingBoundary.data.type === 'boundary') {
                const sizeMenu = document.getElementById('tcalc-size-menu');
                if (sizeMenu.style.display !== 'block') {
                    showSizeMenu(currentEditingBoundary);
                }
            } else if (currentTool === 'polygon' && drawingPath && drawingPath.length > 0) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –∑–∞–º–∫–Ω—É—Ç—å –ø–æ–ª–∏–≥–æ–Ω (–∫–ª–∏–∫ –ø–æ –ø–µ—Ä–≤–æ–π —Ç–æ—á–∫–µ)
                const pointer = canvas.getPointer(e.e);
                const snappedX = snapToGrid(pointer.x);
                const snappedY = snapToGrid(pointer.y);
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–º—ã–∫–∞–Ω–∏–µ (–∫–ª–∏–∫ –ø–æ –ø–µ—Ä–≤–æ–π —Ç–æ—á–∫–µ —Å –¥–æ–ø—É—Å–∫–æ–º 10px)
                if (drawingPath.length > 2 &&
                    Math.abs(snappedX - drawingPath[0].x) < 10 &&
                    Math.abs(snappedY - drawingPath[0].y) < 10) {
                    // –ó–∞–º—ã–∫–∞–µ–º –ø–æ–ª–∏–≥–æ–Ω
                    finalizePolygon();
                }
                // –ï—Å–ª–∏ –Ω–µ –∑–∞–º—ã–∫–∞–µ–º, —Ç–æ —Ç–æ—á–∫–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ onMouseDown
            }
            
            isDrawing = false;
            startPoint = null;
            
            if (currentZoom > 1) {
                if (currentTool === 'eraser') {
                    canvas.defaultCursor = 'pointer';
                } else {
                    canvas.defaultCursor = 'grab';
                }
            } else {
                if (currentTool === 'ruler') {
                    canvas.defaultCursor = 'crosshair';
                } else if (currentTool === 'eraser') {
                    canvas.defaultCursor = 'pointer';
                } else {
                    canvas.defaultCursor = 'default';
                }
            }
        }
        
        function onMouseWheel(e) {
            e.e.preventDefault();
            
            const delta = e.e.deltaY;
            const zoom = delta > 0 ? 0.9 : 1.1;
            
            const oldZoom = currentZoom;
            currentZoom *= zoom;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞—Å—à—Ç–∞–± (–º–∏–Ω–∏–º—É–º 100%, –º–∞–∫—Å–∏–º—É–º 700%)
            if (currentZoom < 1) currentZoom = 1;
            if (currentZoom > 7) currentZoom = 7;
            
            if (oldZoom !== currentZoom) {
                // –û—Ç–∫–ª—é—á–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–æ –≤—Ä–µ–º—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                canvas.renderOnAddRemove = false;
                
                // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö —ç–∫—Ä–∞–Ω–∞
                const mouseX = e.e.clientX;
                const mouseY = e.e.clientY;
                
                // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö canvas
                const pointer = canvas.getPointer(e.e);
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Å—à—Ç–∞–±
                canvas.setZoom(currentZoom);
                
                // –í—ã—á–∏—Å–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –∫—É—Ä—Å–æ—Ä–µ
                const zoomRatio = currentZoom / oldZoom;
                const vpt = canvas.viewportTransform;
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é viewport –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —ç–∫—Ä–∞–Ω–∞ –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                const canvasRect = canvas.wrapperEl.getBoundingClientRect();
                const canvasMouseX = mouseX - canvasRect.left;
                const canvasMouseY = mouseY - canvasRect.top;
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–º–µ—â–µ–Ω–∏–µ viewport
                const newVpt4 = canvasMouseX - (canvasMouseX - vpt[4]) * zoomRatio;
                const newVpt5 = canvasMouseY - (canvasMouseY - vpt[5]) * zoomRatio;
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é viewport
                vpt[4] = newVpt4;
                vpt[5] = newVpt5;
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º viewport transform
                canvas.setViewportTransform(vpt);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è –º–∞—Å—à—Ç–∞–±–∞
                const zoomLevelElement = document.getElementById('tcalc-zoom-level');
                if (zoomLevelElement && !zoomLevelElement.classList.contains('tcalc-zoom-input')) {
                    zoomLevelElement.textContent = Math.round(currentZoom * 100) + '%';
                }
                
                // –í–∫–ª—é—á–∞–µ–º/–≤—ã–∫–ª—é—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
                if (currentZoom > 1) {
                    enablePanning();
                } else {
                    disablePanning();
                }
                
                // –í–∫–ª—é—á–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –æ–±—Ä–∞—Ç–Ω–æ –∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
                canvas.renderOnAddRemove = true;
                canvas.renderAll();
            }
        }
        
        function onMouseDoubleClick(e) {
            // –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ–ª–∏–≥–æ–Ω–∞
            if (currentTool === 'polygon' && drawingPath && drawingPath.length > 2) {
                finalizePolygon();
                return;
            }
            
            // –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è –≤—ã–±–æ—Ä–∞ —É—á–∞—Å—Ç–∫–∞ –∏–ª–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
            if (e.target && e.target.data && (e.target.data.type === 'boundary' || e.target.data.type === 'polygon-boundary')) {
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—ä–µ–∫—Ç –∫–∞–∫ –∞–∫—Ç–∏–≤–Ω—ã–π
                canvas.setActiveObject(e.target);
                
                // –í–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                e.target.selectable = true;
                e.target.evented = true;
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º—ã–π —É—á–∞—Å—Ç–æ–∫
                currentEditingBoundary = e.target;
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é —Ä–∞–∑–º–µ—Ä–æ–≤
                showSizeMenu(e.target);
                
                canvas.renderAll();
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É
                const status = document.getElementById('tcalc-status');
                if (e.target.data.type === 'boundary') {
                    status.textContent = '–£—á–∞—Å—Ç–æ–∫ –≤—ã–±—Ä–∞–Ω. –í–≤–µ–¥–∏—Ç–µ —Ç–æ—á–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∑–∞ —É–≥–ª—ã.';
                } else {
                    status.textContent = '–ü–æ–ª–∏–≥–æ–Ω –≤—ã–±—Ä–∞–Ω. –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∑–∞ —É–≥–ª—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º—ã.';
                }
                
                console.log('–û–±—ä–µ–∫—Ç –≤—ã–±—Ä–∞–Ω –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:', e.target.data.type);
            }
        }

        function fillAreaWithTiles() {
            // –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—Ü—ã —É—á–∞—Å—Ç–∫–∞ (–≤–∫–ª—é—á–∞—è –ø–æ–ª–∏–≥–æ–Ω—ã)
            const boundaries = canvas.getObjects().filter(obj => 
                obj.data && (obj.data.type === 'boundary' || obj.data.type === 'polygon-boundary')
            );
            
            if (boundaries.length === 0) {
                alert('–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ä–∏—Å—É–π—Ç–µ –ø–ª–æ—â–∞–¥–∫—É!');
                return;
            }
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏
            const btn = document.querySelector('[onclick="fillAreaWithTiles()"]');
            const originalText = btn.textContent;
            btn.textContent = '–ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ...';
            btn.disabled = true;
            
            // –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–ª–∏—Ç–∫–∏
            const tiles = canvas.getObjects().filter(obj => 
                obj.data && obj.data.type === 'tile'
            );
            tiles.forEach(tile => canvas.remove(tile));
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
            fillBoundariesGradually(boundaries, 0, btn, originalText);
        }

        function fillBoundariesGradually(boundaries, index, btn, originalText) {
            if (index >= boundaries.length) {
                // –í—Å–µ —É—á–∞—Å—Ç–∫–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã
                canvas.renderAll();
                updateResults();
                updateStatistics();
                btn.textContent = originalText;
                btn.disabled = false;
                
                // –°–∫—Ä—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                document.getElementById('tcalc-progress').style.display = 'none';
                return;
            }
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
            const progress = document.getElementById('tcalc-progress');
            const progressFill = document.getElementById('tcalc-progress-fill');
            const progressText = document.getElementById('tcalc-progress-text');
            
            progress.style.display = 'block';
            const percent = Math.round((index / boundaries.length) * 100);
            progressFill.style.width = percent + '%';
            progressText.textContent = `–ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —É—á–∞—Å—Ç–∫–∞ ${index + 1} –∏–∑ ${boundaries.length}...`;
            
            const boundary = boundaries[index];
            fillBoundaryGradually(boundary, 0, () => {
                // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —É—á–∞—Å—Ç–∫—É
                setTimeout(() => {
                    fillBoundariesGradually(boundaries, index + 1, btn, originalText);
                }, 50);
            });
        }

        function fillBoundaryGradually(boundary, tileCount, callback) {
            // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã –æ–±–ª–∞—Å—Ç–∏ —Å —É—á–µ—Ç–æ–º –ø–æ–≤–æ—Ä–æ—Ç–∞
            let bounds = getBoundaryBounds(boundary);
            
            if (!bounds) {
                callback();
                return;
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä—ã –æ–±–ª–∞—Å—Ç–∏
            const areaWidth = bounds.right - bounds.left;
            const areaHeight = bounds.bottom - bounds.top;
            
            if (areaWidth < 1.1 || areaHeight < 2.2) {
                callback();
                return;
            }
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –ø–æ–ª–∏–≥–æ–Ω–æ–≤ - —É–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å —Ç–æ—á–∫–∏
            if (bounds.polygon && (!bounds.points || bounds.points.length < 3)) {
                console.warn('–ü–æ–ª–∏–≥–æ–Ω –Ω–µ –∏–º–µ–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ—á–µ–∫ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è');
                callback();
                return;
            }
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Ç–∫—É –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—ã–∑–æ–≤–µ
            if (tileCount === 0) {
                boundary.grid = {};
                boundary.tileIndex = 0;
                boundary.horizontalCount = 0;
                boundary.verticalCount = 0;
            }
            
            const grid = boundary.grid;
            const tileTypes = ['large', 'medium', 'small'];
            let tileIndex = boundary.tileIndex;
            let horizontalCount = boundary.horizontalCount;
            let verticalCount = boundary.verticalCount;
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —Å–≤–æ–±–æ–¥–Ω–æ –ª–∏ –º–µ—Å—Ç–æ
            function isSpaceFree(x, y, width, height) {
                if (bounds.polygon) {
                    // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —Å–µ—Ç–∫–∏
                    for (let i = x; i < x + width; i += 1.1) {
                        for (let j = y; j < y + height; j += 1.1) {
                            if (grid[`${Math.round(i)},${Math.round(j)}`]) return false;
                        }
                    }
                    return true;
                } else if (bounds.rotated) {
                    // –î–ª—è –ø–æ–≤–µ—Ä–Ω—É—Ç—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –ø–ª–∏—Ç–∫–∞–º–∏
                    const newTileBounds = {
                        left: x,
                        top: y,
                        right: x + width,
                        bottom: y + height
                    };
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –ø–ª–∏—Ç–∫–∞–º–∏
                    for (let i = x; i < x + width; i += 0.5) {
                        for (let j = y; j < y + height; j += 0.5) {
                            if (grid[`${Math.round(i)},${Math.round(j)}`]) return false;
                        }
                    }
                    return true;
                } else {
                    // –î–ª—è –Ω–µ–ø–æ–≤–µ—Ä–Ω—É—Ç—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
                    for (let i = x; i < x + width; i++) {
                        for (let j = y; j < y + height; j++) {
                            if (grid[`${i},${j}`]) return false;
                        }
                    }
                    return true;
                }
            }
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–º–µ—Ç–∫–∏ –º–µ—Å—Ç–∞ –∫–∞–∫ –∑–∞–Ω—è—Ç–æ–≥–æ
            function markSpaceOccupied(x, y, width, height) {
                if (bounds.polygon) {
                    // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é —Å–µ—Ç–∫—É
                    for (let i = x; i < x + width; i += 1.1) {
                        for (let j = y; j < y + height; j += 1.1) {
                            grid[`${Math.round(i)},${Math.round(j)}`] = true;
                        }
                    }
                } else if (bounds.rotated) {
                    // –î–ª—è –ø–æ–≤–µ—Ä–Ω—É—Ç—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤ –æ—Ç–º–µ—á–∞–µ–º –±–æ–ª–µ–µ –ø–ª–æ—Ç–Ω—É—é —Å–µ—Ç–∫—É
                    for (let i = x; i < x + width; i += 0.5) {
                        for (let j = y; j < y + height; j += 0.5) {
                            grid[`${Math.round(i)},${Math.round(j)}`] = true;
                        }
                    }
                } else {
                    // –î–ª—è –Ω–µ–ø–æ–≤–µ—Ä–Ω—É—Ç—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—É—é —Å–µ—Ç–∫—É
                    for (let i = x; i < x + width; i++) {
                        for (let j = y; j < y + height; j++) {
                            grid[`${i},${j}`] = true;
                        }
                    }
                }
            }
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –º–µ—Å—Ç–∞ –¥–ª—è –ø–ª–∏—Ç–∫–∏ —Å —É—á–µ—Ç–æ–º –ø–æ–≤–æ—Ä–æ—Ç–∞
            function findPosition(width, height) {
                if (bounds.polygon) {
                    // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é –≤–æ–∑–º–æ–∂–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –≤ —Ç–µ–∫—É—â–∏—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
                    const step = 1.1; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —à–∞–≥ —Å–µ—Ç–∫–∏
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª–∏–≥–æ–Ω–∞
                    for (let y = bounds.top; y <= bounds.bottom - height; y += step) {
                        for (let x = bounds.left; x <= bounds.right - width; x += step) {
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —É–≥–ª—ã –ø–ª–∏—Ç–∫–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
                            const corners = [
                                { x: x, y: y },
                                { x: x + width, y: y },
                                { x: x + width, y: y + height },
                                { x: x, y: y + height }
                            ];
                            
                            let allCornersInside = true;
                            for (let corner of corners) {
                                if (!isPointInPolygon(corner, bounds.points)) {
                                    allCornersInside = false;
                                    break;
                                }
                            }
                            
                            if (allCornersInside && isSpaceFree(x, y, width, height)) {
                                return { x: x, y: y };
                            }
                        }
                    }
                    
                    // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –º–µ—Å—Ç–æ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null
                    return null;
                } else if (bounds.rotated) {
                    // –î–ª—è –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ—Ç–∫—É, –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ø–æ —É–≥–ª—É –Ω–∞–∫–ª–æ–Ω–∞
                    const step = 1.1; // –®–∞–≥ —Å–µ—Ç–∫–∏
                    const angle = bounds.angle * Math.PI / 180;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —Å–µ—Ç–∫–∏ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –Ω–∞–∫–ª–æ–Ω–∞
                    const gridWidth = bounds.originalWidth;
                    const gridHeight = bounds.originalHeight;
                    
                    // –°–æ–∑–¥–∞–µ–º —Å–µ—Ç–∫—É –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –Ω–∞–∫–ª–æ–Ω–∞
                    for (let gridY = 0; gridY <= gridHeight - height; gridY += step) {
                        for (let gridX = 0; gridX <= gridWidth - width; gridX += step) {
                            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–µ—Ç–∫–∏ –≤ –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                            const worldX = bounds.center.x + (gridX - gridWidth/2 + width/2) * cos - (gridY - gridHeight/2 + height/2) * sin;
                            const worldY = bounds.center.y + (gridX - gridWidth/2 + width/2) * sin + (gridY - gridHeight/2 + height/2) * cos;
                            
                            const tileCenter = { x: worldX, y: worldY };
                            if (isPointInRotatedRectangle(tileCenter, bounds) && isSpaceFree(worldX - width/2, worldY - height/2, width, height)) {
                                return { x: worldX - width/2, y: worldY - height/2 };
                            }
                        }
                    }
                } else {
                    // –î–ª—è –Ω–µ–ø–æ–≤–µ—Ä–Ω—É—Ç–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—É—é —Å–µ—Ç–∫—É
                    for (let y = bounds.top; y <= bounds.bottom - height; y++) {
                        for (let x = bounds.left; x <= bounds.right - width; x++) {
                            if (isSpaceFree(x, y, width, height)) {
                                return { x, y };
                            }
                        }
                    }
                }
                return null;
            }
            
            // –†–∞–∑–º–µ—â–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–ª–∏—Ç–æ–∫ –∑–∞ —Ä–∞–∑ (–¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è)
            const tilesPerBatch = bounds.polygon ? 3 : 5; // –ú–µ–Ω—å—à–µ –ø–ª–∏—Ç–æ–∫ –∑–∞ —Ä–∞–∑ –¥–ª—è –ø–æ–ª–∏–≥–æ–Ω–æ–≤
            let placedTiles = 0;
            let attempts = 0;
            const maxAttempts = bounds.polygon ? 50 : 100; // –ú–µ–Ω—å—à–µ –ø–æ–ø—ã—Ç–æ–∫ –¥–ª—è –ø–æ–ª–∏–≥–æ–Ω–æ–≤
            
            // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –ø–æ–ª–∏–≥–æ–Ω–æ–≤
            if (bounds.polygon) {
                console.log('–ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–∞:', {
                    bounds: bounds,
                    tileCount: tileCount,
                    maxAttempts: maxAttempts,
                    tilesPerBatch: tilesPerBatch
                });
            }
            
            while (placedTiles < tilesPerBatch && attempts < maxAttempts) {
                attempts++;
                
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–≤–∏—Å–∞–Ω–∏—è
                if (bounds.polygon && attempts > 20 && placedTiles === 0) {
                    console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –ø–ª–∏—Ç–∫–∏ –≤ –ø–æ–ª–∏–≥–æ–Ω–µ –ø–æ—Å–ª–µ 20 –ø–æ–ø—ã—Ç–æ–∫, –∑–∞–≤–µ—Ä—à–∞–µ–º');
                    break;
                }
                
                // –í—ã–±–∏—Ä–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–ª–∏—Ç–∫–∏ —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º –Ω–∞ –±–æ–ª—å—à–∏–µ
                let tileType;
                if (tileIndex % 4 === 0) {
                    tileType = 'large';
                } else if (tileIndex % 4 === 1) {
                    tileType = 'medium';
                } else {
                    tileType = 'small';
                }
                
                const config = TILE_CONFIG[tileType];
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
                let isVertical = false;
                const areaWidth = bounds.right - bounds.left;
                const areaHeight = bounds.bottom - bounds.top;
                
                if (areaHeight > areaWidth) {
                    isVertical = true;
                }
                
                let finalWidth = config.width;
                let finalHeight = config.height;
                
                if (isVertical) {
                    [finalWidth, finalHeight] = [finalHeight, finalWidth];
                }
                
                // –ò—â–µ–º –º–µ—Å—Ç–æ –¥–ª—è –ø–ª–∏—Ç–∫–∏
                let position = findPosition(finalWidth, finalHeight);
                
                if (position) {
                    let tile;
                    
                    if (bounds.rotated) {
                        // –°–æ–∑–¥–∞–µ–º –ø–æ–≤–µ—Ä–Ω—É—Ç—É—é –ø–ª–∏—Ç–∫—É
                        tile = createRotatedTile(position, finalWidth, finalHeight, tileType, bounds);
                    } else if (bounds.polygon) {
                        // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ —Å–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—É—é –ø–ª–∏—Ç–∫—É –±–µ–∑ –ø–æ–≤–æ—Ä–æ—Ç–∞
                        const gradient = new fabric.Gradient({
                            type: 'linear',
                            coords: {
                                x1: 0,
                                y1: 0,
                                x2: finalWidth,
                                y2: finalHeight
                            },
                            colorStops: [
                                { offset: 0, color: '#ffffff' },
                                { offset: 1, color: '#cccccc' }
                            ]
                        });
                        
                        tile = new fabric.Rect({
                            left: position.x,
                            top: position.y,
                            width: finalWidth,
                            height: finalHeight,
                            fill: gradient,
                            stroke: '#d2b48c',
                            strokeWidth: 0.05,
                            selectable: false,
                            data: { 
                                type: 'tile',
                                tileType: tileType,
                                orientation: isVertical ? 'vertical' : 'horizontal'
                            }
                        });
                    } else {
                        // –°–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—É—é –ø–ª–∏—Ç–∫—É
                        const gradient = new fabric.Gradient({
                            type: 'linear',
                            coords: {
                                x1: 0,
                                y1: 0,
                                x2: finalWidth,
                                y2: finalHeight
                            },
                            colorStops: [
                                { offset: 0, color: '#ffffff' },
                                { offset: 1, color: '#cccccc' }
                            ]
                        });
                        
                        tile = new fabric.Rect({
                            left: position.x,
                            top: position.y,
                            width: finalWidth,
                            height: finalHeight,
                            fill: gradient,
                            stroke: '#d2b48c',
                            strokeWidth: 0.05,
                            selectable: false,
                            data: { 
                                type: 'tile',
                                tileType: tileType,
                                orientation: isVertical ? 'vertical' : 'horizontal'
                            }
                        });
                    }
                    
                    canvas.add(tile);
                    markSpaceOccupied(position.x, position.y, finalWidth, finalHeight);
                    placedTiles++;
                    tileIndex++;
                } else {
                    // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –º–µ—Å—Ç–æ –¥–ª—è —ç—Ç–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞, –ø—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π
                    tileIndex++;
                }
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            boundary.tileIndex = tileIndex;
            boundary.horizontalCount = horizontalCount;
            boundary.verticalCount = verticalCount;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º canvas –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            canvas.renderAll();
            updateResults();
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å
            if (placedTiles > 0 && tileIndex < 500) { // –£–º–µ–Ω—å—à–∞–µ–º –ª–∏–º–∏—Ç –¥–ª—è –ø–æ–ª–∏–≥–æ–Ω–æ–≤
                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
                setTimeout(() => {
                    fillBoundaryGradually(boundary, tileCount + placedTiles, callback);
                }, 10); // –ë—ã—Å—Ç—Ä–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
            } else {
                // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ—Å—Ç–∞–≤—à—É—é—Å—è –æ–±–ª–∞—Å—Ç—å –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –ø–ª–∏—Ç–∫–∞–º–∏
                fillRemainingArea();
                callback();
            }
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Å—Ç–∞–≤—à–µ–π—Å—è –æ–±–ª–∞—Å—Ç–∏ –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –ø–ª–∏—Ç–∫–∞–º–∏
            function fillRemainingArea() {
                if (bounds.rotated) {
                    // –î–ª—è –ø–æ–≤–µ—Ä–Ω—É—Ç—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ—Ç–∫—É, –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ø–æ —É–≥–ª—É –Ω–∞–∫–ª–æ–Ω–∞
                    const step = 1.1;
                    const angle = bounds.angle * Math.PI / 180;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —Å–µ—Ç–∫–∏ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –Ω–∞–∫–ª–æ–Ω–∞
                    const gridWidth = bounds.originalWidth;
                    const gridHeight = bounds.originalHeight;
                    
                    // –°–æ–∑–¥–∞–µ–º —Å–µ—Ç–∫—É –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –Ω–∞–∫–ª–æ–Ω–∞
                    for (let gridY = 0; gridY <= gridHeight - step; gridY += step) {
                        for (let gridX = 0; gridX <= gridWidth - step; gridX += step) {
                            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–µ—Ç–∫–∏ –≤ –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                            const worldX = bounds.center.x + (gridX - gridWidth/2 + step/2) * cos - (gridY - gridHeight/2 + step/2) * sin;
                            const worldY = bounds.center.y + (gridX - gridWidth/2 + step/2) * sin + (gridY - gridHeight/2 + step/2) * cos;
                            
                            const tileCenter = { x: worldX, y: worldY };
                            
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–ª–∏—Ç–∫–∞ –≤–Ω—É—Ç—Ä–∏ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–≥–æ —É—á–∞—Å—Ç–∫–∞
                            if (isPointInRotatedRectangle(tileCenter, bounds)) {
                                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç–æ –ª–∏ –º–µ—Å—Ç–æ
                                let isOccupied = false;
                                canvas.getObjects().forEach(obj => {
                                    if (obj.data && obj.data.type === 'tile') {
                                        if (worldX - step/2 < obj.left + obj.width && worldX + step/2 > obj.left &&
                                            worldY - step/2 < obj.top + obj.height && worldY + step/2 > obj.top) {
                                            isOccupied = true;
                                        }
                                    }
                                });
                                
                                if (!isOccupied) {
                                    const tile = createRotatedTile({ x: worldX - step/2, y: worldY - step/2 }, step, step, 'small', bounds);
                                    canvas.add(tile);
                                }
                            }
                        }
                    }
                } else if (bounds.polygon) {
                    // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –∑–∞–ø–æ–ª–Ω—è–µ–º –æ—Å—Ç–∞–≤—à—É—é—Å—è –æ–±–ª–∞—Å—Ç—å –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –ø–ª–∏—Ç–∫–∞–º–∏
                    const step = 1.1;
                    
                    for (let y = bounds.top; y <= bounds.bottom - step; y += step) {
                        for (let x = bounds.left; x <= bounds.right - step; x += step) {
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ü–µ–Ω—Ç—Ä –ø–ª–∏—Ç–∫–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
                            const tileCenter = { x: x + step/2, y: y + step/2 };
                            
                            if (isPointInPolygon(tileCenter, bounds.points)) {
                                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç–æ –ª–∏ –º–µ—Å—Ç–æ
                                let isOccupied = false;
                                canvas.getObjects().forEach(obj => {
                                    if (obj.data && obj.data.type === 'tile') {
                                        if (x < obj.left + obj.width && x + step > obj.left &&
                                            y < obj.top + obj.height && y + step > obj.top) {
                                            isOccupied = true;
                                        }
                                    }
                                });
                                
                                if (!isOccupied) {
                                    const gradient = new fabric.Gradient({
                                        type: 'linear',
                                        coords: { x1: 0, y1: 0, x2: step, y2: step },
                                        colorStops: [
                                            { offset: 0, color: '#ffffff' },
                                            { offset: 1, color: '#cccccc' }
                                        ]
                                    });
                                    
                                    const tile = new fabric.Rect({
                                        left: x,
                                        top: y,
                                        width: step,
                                        height: step,
                                        fill: gradient,
                                        stroke: '#d2b48c',
                                        strokeWidth: 0.05,
                                        selectable: false,
                                        data: { 
                                            type: 'tile',
                                            tileType: 'small',
                                            orientation: 'square'
                                        }
                                    });
                                    
                                    canvas.add(tile);
                                }
                            }
                        }
                    }
                } else {
                    // –î–ª—è –Ω–µ–ø–æ–≤–µ—Ä–Ω—É—Ç—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º
                    const areaWidth = bounds.right - bounds.left;
                    const areaHeight = bounds.bottom - bounds.top;
                    const totalArea = areaWidth * areaHeight;
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –ø–ª–æ—â–∞–¥—å —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—É—é –ø–ª–∏—Ç–∫–∞–º–∏
                    let filledArea = 0;
                    canvas.getObjects().forEach(obj => {
                        if (obj.data && obj.data.type === 'tile' && 
                            obj.left >= bounds.left && obj.top >= bounds.top &&
                            obj.left + obj.width <= bounds.right && obj.top + obj.height <= bounds.bottom) {
                            filledArea += obj.width * obj.height;
                        }
                    });
                    
                    // –ï—Å–ª–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ –º–µ–Ω—å—à–µ 90%, –∑–∞–ø–æ–ª–Ω—è–µ–º –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –ø–ª–∏—Ç–∫–∞–º–∏
                    const targetFillArea = totalArea * 0.9;
                    if (filledArea < targetFillArea) {
                        
                        // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ—Å—Ç–∞–≤—à—É—é—Å—è –æ–±–ª–∞—Å—Ç—å –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –ø–ª–∏—Ç–∫–∞–º–∏
                        for (let y = bounds.top; y <= bounds.bottom - 1.1; y += 1.1) {
                            for (let x = bounds.left; x <= bounds.right - 1.1; x += 1.1) {
                                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç–æ –ª–∏ –º–µ—Å—Ç–æ
                                let isOccupied = false;
                                canvas.getObjects().forEach(obj => {
                                    if (obj.data && obj.data.type === 'tile') {
                                        if (x < obj.left + obj.width && x + 1.1 > obj.left &&
                                            y < obj.top + obj.height && y + 1.1 > obj.top) {
                                            isOccupied = true;
                                        }
                                    }
                                });
                                
                                if (!isOccupied) {
                                    const gradient = new fabric.Gradient({
                                        type: 'linear',
                                        coords: { x1: 0, y1: 0, x2: 1.1, y2: 1.1 },
                                        colorStops: [
                                            { offset: 0, color: '#ffffff' },
                                            { offset: 1, color: '#cccccc' }
                                        ]
                                    });
                                    
                                    const tile = new fabric.Rect({
                                        left: x,
                                        top: y,
                                        width: 1.1,
                                        height: 1.1,
                                        fill: gradient,
                                        stroke: '#d2b48c',
                                        strokeWidth: 0.05,
                                        selectable: false,
                                        data: { 
                                            type: 'tile',
                                            tileType: 'small',
                                            orientation: 'square'
                                        }
                                    });
                                    
                                    canvas.add(tile);
                                }
                            }
                        }
                    }
                }
            }
        }

        function clearTiles() {
            const tiles = canvas.getObjects().filter(obj => 
                obj.data && obj.data.type === 'tile'
            );
            tiles.forEach(tile => canvas.remove(tile));
            canvas.renderAll();
            updateResults();
        }

        function clearCanvas() {
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë?')) {
                canvas.clear();
                canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
                updateResults();
            }
        }

        function updateResults() {
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫–∏
            tileCounts = {
                'large': 0,
                'medium': 0,
                'small': 0
            };
            
            // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–ª–∏—Ç–∫–∏
            canvas.getObjects().forEach(obj => {
                if (obj.data && obj.data.type === 'tile' && obj.data.tileType) {
                    tileCounts[obj.data.tileType]++;
                }
            });
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            document.getElementById('tcalc-count-large').textContent = tileCounts['large'];
            document.getElementById('tcalc-count-medium').textContent = tileCounts['medium'];
            document.getElementById('tcalc-count-small').textContent = tileCounts['small'];
            
            const total = tileCounts['large'] + tileCounts['medium'] + tileCounts['small'];
            document.getElementById('tcalc-total-count').textContent = total;
        }

        function saveProject() {
            const project = {
                background: canvas.backgroundImage ? canvas.backgroundImage.toDataURL() : null,
                objects: canvas.toJSON(),
                tileCounts: tileCounts,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('tcalcProject', JSON.stringify(project));
            alert('–ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!');
        }

        function loadProject() {
            const saved = localStorage.getItem('tcalcProject');
            if (!saved) {
                alert('–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –ø—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }
            
            try {
                const project = JSON.parse(saved);
                
                canvas.loadFromJSON(project.objects, function() {
                    if (project.background) {
                        fabric.Image.fromURL(project.background, function(img) {
                            canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                        });
                    }
                    canvas.renderAll();
                    
                    if (project.tileCounts) {
                        tileCounts = project.tileCounts;
                        updateResults();
                    }
                });
                
                alert('–ü—Ä–æ–µ–∫—Ç –∑–∞–≥—Ä—É–∂–µ–Ω!');
            } catch (error) {
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–æ–µ–∫—Ç–∞');
                console.error(error);
            }
        }
        

        
        function updateStatistics() {
            // –í—ã—á–∏—Å–ª—è–µ–º –ø–ª–æ—â–∞–¥—å —É—á–∞—Å—Ç–∫–∞
            const boundaries = canvas.getObjects().filter(obj => 
                obj.data && (obj.data.type === 'boundary' || obj.data.type === 'polygon-boundary')
            );
            
            let totalArea = 0;
            let totalPerimeter = 0;
            let maxLength = 0;
            let maxWidth = 0;
            
            boundaries.forEach(boundary => {
                if (boundary.type === 'rect') {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–µ —Ä–∞–∑–º–µ—Ä—ã —Å —É—á–µ—Ç–æ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
                    const currentWidth = boundary.width * (boundary.scaleX || 1);
                    const currentHeight = boundary.height * (boundary.scaleY || 1);
                    
                    const area = (currentWidth * currentHeight) / 100; // –≤ –º¬≤ (1px = 100–º–º = 0.1–º)
                    const perimeter = 2 * (currentWidth + currentHeight) / 10; // –≤ –º
                    const length = Math.max(currentWidth, currentHeight) / 10; // –≤ –º
                    const width = Math.min(currentWidth, currentHeight) / 10; // –≤ –º
                    
                    totalArea += area;
                    totalPerimeter += perimeter;
                    maxLength = Math.max(maxLength, length);
                    maxWidth = Math.max(maxWidth, width);
                } else if (boundary.data && boundary.data.type === 'polygon-boundary') {
                    // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—É—é –ø–ª–æ—â–∞–¥—å
                    const area = boundary.data.area || 0;
                    totalArea += area;
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –ø–æ–ª–∏–≥–æ–Ω–∞
                    const width = boundary.data.width || 0;
                    const height = boundary.data.height || 0;
                    const length = Math.max(width, height);
                    const widthValue = Math.min(width, height);
                    
                    maxLength = Math.max(maxLength, length);
                    maxWidth = Math.max(maxWidth, widthValue);
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –ø–µ—Ä–∏–º–µ—Ç—Ä –∏–∑ –¥–ª–∏–Ω —Å—Ç–æ—Ä–æ–Ω
                    if (boundary.data.lengths) {
                        const perimeter = boundary.data.lengths.reduce((sum, length) => sum + parseFloat(length), 0);
                        totalPerimeter += perimeter;
                    }
                }
            });
            
            // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã –æ–±–ª–∞—Å—Ç–∏ —Å –ø–ª–∏—Ç–∫–∞–º–∏
            const tiles = canvas.getObjects().filter(obj => 
                obj.data && obj.data.type === 'tile'
            );
            
            let tilesMinX = Infinity;
            let tilesMaxX = -Infinity;
            let tilesMinY = Infinity;
            let tilesMaxY = -Infinity;
            
            tiles.forEach(tile => {
                const left = tile.left;
                const top = tile.top;
                const right = left + tile.width;
                const bottom = top + tile.height;
                
                tilesMinX = Math.min(tilesMinX, left);
                tilesMaxX = Math.max(tilesMaxX, right);
                tilesMinY = Math.min(tilesMinY, top);
                tilesMaxY = Math.max(tilesMaxY, bottom);
            });
            
            // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã –æ–±–ª–∞—Å—Ç–∏ —Å –ø–ª–∏—Ç–∫–∞–º–∏
            let tilesLength = 0;
            let tilesWidth = 0;
            
            if (tiles.length > 0 && tilesMinX !== Infinity) {
                const tilesAreaWidth = tilesMaxX - tilesMinX;
                const tilesAreaHeight = tilesMaxY - tilesMinY;
                tilesLength = Math.max(tilesAreaWidth, tilesAreaHeight) / 10; // –≤ –º
                tilesWidth = Math.min(tilesAreaWidth, tilesAreaHeight) / 10; // –≤ –º
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            document.getElementById('tcalc-area').textContent = totalArea.toFixed(1) + ' –º¬≤';
            document.getElementById('tcalc-perimeter').textContent = totalPerimeter.toFixed(1) + ' –º';
            document.getElementById('tcalc-length').textContent = maxLength.toFixed(1) + ' –º';
            document.getElementById('tcalc-width').textContent = maxWidth.toFixed(1) + ' –º';
            document.getElementById('tcalc-tiles-length').textContent = tilesLength.toFixed(1) + ' –º';
            document.getElementById('tcalc-tiles-width').textContent = tilesWidth.toFixed(1) + ' –º';
        }
        
        function exportResults() {
            // –°–æ–∑–¥–∞–µ–º PDF —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
            const results = {
                area: document.getElementById('tcalc-area').textContent,
                perimeter: document.getElementById('tcalc-perimeter').textContent,
                coverage: document.getElementById('tcalc-coverage').textContent,
                cost: document.getElementById('tcalc-cost').textContent,
                tiles: tileCounts,
                total: document.getElementById('tcalc-total-count').textContent
            };
            
            // –ü—Ä–æ—Å—Ç–æ–π —ç–∫—Å–ø–æ—Ä—Ç –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
            const exportText = `
–†–ê–°–ß–ï–¢ –ü–õ–ò–¢–ö–ò "–ù–û–í–´–ô –ì–û–†–û–î"

–ü–ª–æ—â–∞–¥—å —É—á–∞—Å—Ç–∫–∞: ${results.area}
–ü–µ—Ä–∏–º–µ—Ç—Ä: ${results.perimeter}
–ü–æ–∫—Ä—ã—Ç–∏–µ: ${results.coverage}
–û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å: ${results.cost}

–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–∏—Ç–æ–∫:
- –ë–æ–ª—å—à–∞—è (330√ó220): ${results.tiles.large} —à—Ç.
- –°—Ä–µ–¥–Ω—è—è (220√ó220): ${results.tiles.medium} —à—Ç.
- –ú–∞–ª–∞—è (110√ó220): ${results.tiles.small} —à—Ç.

–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${results.total} —à—Ç.

–î–∞—Ç–∞ —Ä–∞—Å—á–µ—Ç–∞: ${new Date().toLocaleDateString()}
            `;
            
            // –°–æ–∑–¥–∞–µ–º –∏ —Å–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '—Ä–∞—Å—á–µ—Ç-–ø–ª–∏—Ç–∫–∏.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ —Ñ–∞–π–ª —Ä–∞—Å—á–µ—Ç-–ø–ª–∏—Ç–∫–∏.txt');
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
        function onObjectModified(e) {
            if (e.target && e.target.data && e.target.data.type === 'tile') {
                updateResults();
                updateStatistics();
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é —Ä–∞–∑–º–µ—Ä–æ–≤ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø–ª–æ—â–∞–¥–∫–∏
            if (e.target && e.target.data && (e.target.data.type === 'boundary' || e.target.data.type === 'polygon-boundary')) {
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–æ—â–∞–¥–∫—É –∫–∞–∫ –∞–∫—Ç–∏–≤–Ω—É—é
                currentEditingBoundary = e.target;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ–≥–æ –µ—Å–ª–∏ —Å–∫—Ä—ã—Ç–æ
                if (e.target.data.type === 'boundary') {
                    updateSizeMenu(e.target);
                } else if (e.target.data.type === 'polygon-boundary') {
                    // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–ª–æ—â–∞–¥—å –∏ —Ä–∞–∑–º–µ—Ä—ã –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏
                    const points = e.target.points || e.target._points;
                    if (points && points.length > 2) {
                        const area = calculatePolygonArea(points);
                        const dimensions = calculatePolygonDimensions(points);
                        const angle = calculatePolygonAngle(points);
                        const lengths = calculatePolygonLengths(points);
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª–∏–≥–æ–Ω–∞
                        e.target.data.area = area;
                        e.target.data.width = dimensions.width;
                        e.target.data.height = dimensions.height;
                        e.target.data.angle = angle;
                        e.target.data.lengths = lengths;
                        
                        console.log('–ü–æ–ª–∏–≥–æ–Ω –∏–∑–º–µ–Ω–µ–Ω - –Ω–æ–≤–∞—è –ø–ª–æ—â–∞–¥—å:', area, '—Ä–∞–∑–º–µ—Ä—ã:', dimensions, '—É–≥–æ–ª:', angle, '–¥–ª–∏–Ω—ã —Å—Ç–æ—Ä–æ–Ω:', lengths);
                    }
                    showSizeMenu(e.target);
                }
                
                const sizeMenu = document.getElementById('tcalc-size-menu');
                if (sizeMenu.style.display !== 'block') {
                    showSizeMenu(e.target);
                }
                
                updateStatistics();
                
                // –°–∫—Ä—ã–≤–∞–µ–º —É–≥–æ–ª —Ä—è–¥–æ–º —Å –∫—É—Ä—Å–æ—Ä–æ–º –ø—Ä–∏ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞
                hideCursorAngle();
            }
        }
        
        function onObjectMoving(e) {
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é —Ä–∞–∑–º–µ—Ä–æ–≤ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –ø–ª–æ—â–∞–¥–∫–∏
            if (e.target && e.target.data && (e.target.data.type === 'boundary' || e.target.data.type === 'polygon-boundary')) {
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–æ—â–∞–¥–∫—É –∫–∞–∫ –∞–∫—Ç–∏–≤–Ω—É—é
                currentEditingBoundary = e.target;
                if (e.target.data.type === 'boundary') {
                    updateSizeMenu(e.target);
                } else if (e.target.data.type === 'polygon-boundary') {
                    // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–ª–æ—â–∞–¥—å –∏ —Ä–∞–∑–º–µ—Ä—ã –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏
                    const points = e.target.points || e.target._points;
                    if (points && points.length > 2) {
                        const area = calculatePolygonArea(points);
                        const dimensions = calculatePolygonDimensions(points);
                        const angle = calculatePolygonAngle(points);
                        const lengths = calculatePolygonLengths(points);
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª–∏–≥–æ–Ω–∞
                        e.target.data.area = area;
                        e.target.data.width = dimensions.width;
                        e.target.data.height = dimensions.height;
                        e.target.data.angle = angle;
                        e.target.data.lengths = lengths;
                    }
                    showSizeMenu(e.target);
                }
            }
        }
        
        function onObjectScaling(e) {
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é —Ä–∞–∑–º–µ—Ä–æ–≤ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –ø–ª–æ—â–∞–¥–∫–∏
            if (e.target && e.target.data && (e.target.data.type === 'boundary' || e.target.data.type === 'polygon-boundary')) {
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–æ—â–∞–¥–∫—É –∫–∞–∫ –∞–∫—Ç–∏–≤–Ω—É—é
                currentEditingBoundary = e.target;
                if (e.target.data.type === 'boundary') {
                    updateSizeMenu(e.target);
                } else if (e.target.data.type === 'polygon-boundary') {
                    // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–ª–æ—â–∞–¥—å –∏ —Ä–∞–∑–º–µ—Ä—ã –ø—Ä–∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–∏
                    const points = e.target.points || e.target._points;
                    if (points && points.length > 2) {
                        const area = calculatePolygonArea(points);
                        const dimensions = calculatePolygonDimensions(points);
                        const angle = calculatePolygonAngle(points);
                        const lengths = calculatePolygonLengths(points);
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª–∏–≥–æ–Ω–∞
                        e.target.data.area = area;
                        e.target.data.width = dimensions.width;
                        e.target.data.height = dimensions.height;
                        e.target.data.angle = angle;
                        e.target.data.lengths = lengths;
                    }
                    showSizeMenu(e.target);
                }
            }
        }
        
        function onObjectRotating(e) {
            // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —É–≥–ª–∞ –ø–æ–≤–æ—Ä–æ—Ç–∞
            if (e.target && e.target.data && e.target.data.type === 'boundary') {
                updateRotationIndicator(e.target);
                showCursorAngle(e.target, e.e);
            } else if (e.target && e.target.data && e.target.data.type === 'polygon-boundary') {
                // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —É–≥–æ–ª –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
                const points = e.target.points || e.target._points;
                if (points && points.length > 2) {
                    const angle = calculatePolygonAngle(points);
                    const lengths = calculatePolygonLengths(points);
                    e.target.data.angle = angle;
                    e.target.data.lengths = lengths;
                    showSizeMenu(e.target);
                }
                showCursorAngle(e.target, e.e);
            }
        }
        
        function onSelectionCreated(e) {
            console.log('=== onSelectionCreated –≤—ã–∑–≤–∞–Ω–∞ ===');
            console.log('e.target:', e.target);
            console.log('e.target.data:', e.target?.data);
            console.log('e.target.data.type:', e.target?.data?.type);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –ø–ª–æ—â–∞–¥–∫–∏ –∏–ª–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
            if (e.target && e.target.data && (e.target.data.type === 'boundary' || e.target.data.type === 'polygon-boundary')) {
                currentEditingBoundary = e.target;
                
                if (e.target.data.type === 'boundary') {
                    console.log('–í—ã–±—Ä–∞–Ω –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ (boundary)', e.target);
                    showSizeMenu(e.target);
                    showRotationIndicator(e.target);
                } else if (e.target.data.type === 'polygon-boundary') {
                    console.log('–í—ã–±—Ä–∞–Ω –ø–æ–ª–∏–≥–æ–Ω (polygon-boundary)', e.target);
                    
                    // –ü–æ–ª—É—á–∞–µ–º —Ç–æ—á–∫–∏ –ø–æ–ª–∏–≥–æ–Ω–∞ –∏ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–ª–æ—â–∞–¥—å –∏ —Ä–∞–∑–º–µ—Ä—ã
                    let points = e.target.points || e.target._points;
                    let area = e.target.data.area;
                    let width = e.target.data.width;
                    let height = e.target.data.height;
                    
                    console.log('points:', points);
                    console.log('area:', area);
                    
                    if (points && points.length > 2) {
                        // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–ª–æ—â–∞–¥—å –∏ —Ä–∞–∑–º–µ—Ä—ã
                        area = calculatePolygonArea(points);
                        const dimensions = calculatePolygonDimensions(points);
                        const lengths = calculatePolygonLengths(points);
                        width = dimensions.width;
                        height = dimensions.height;
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª–∏–≥–æ–Ω–∞
                        e.target.data.area = area;
                        e.target.data.width = width;
                        e.target.data.height = height;
                        e.target.data.lengths = lengths;
                        
                        console.log('–ü–µ—Ä–µ—Å—á–∏—Ç–∞–Ω–Ω–∞—è –ø–ª–æ—â–∞–¥—å:', area, '—Ä–∞–∑–º–µ—Ä—ã:', dimensions, '–¥–ª–∏–Ω—ã —Å—Ç–æ—Ä–æ–Ω:', lengths);
                    }
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º size-menu —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
                    showSizeMenu(e.target);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ—è–≤–∏–ª–æ—Å—å –ª–∏ –º–µ–Ω—é
                    const sizeMenu = document.getElementById('tcalc-size-menu');
                    console.log('sizeMenu display –ø–æ—Å–ª–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è:', sizeMenu.style.display);
                }
            }
        }
        
        function onSelectionCleared(e) {
            hideSizeMenu();
            hideRotationIndicator();
            hideCursorAngle();
            document.getElementById('polygon-area-info').style.display = 'none';
            document.getElementById('polygon-stats').style.display = 'none';
            document.getElementById('polygon-angle').style.display = 'none';
        }
        
        // –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        // –û—Ç–º–µ–Ω–∞ –¥–µ–π—Å—Ç–≤–∏—è (–º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é)
                        break;
                    case 's':
                        e.preventDefault();
                        saveProject();
                        break;
                    case 'o':
                        e.preventDefault();
                        loadProject();
                        break;
                }
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ Enter –≤ –ø–æ–ª—è—Ö –≤–≤–æ–¥–∞ —Ä–∞–∑–º–µ—Ä–æ–≤
            if (e.key === 'Enter' && (e.target.id === 'tcalc-length-input' || e.target.id === 'tcalc-width-input')) {
                applySizeToBoundary();
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ Escape –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è –º–µ–Ω—é –∏ –≤—ã–±–æ—Ä–∞
            if (e.key === 'Escape') {
                // –ï—Å–ª–∏ —Ä–∏—Å—É–µ—Ç—Å—è –ø–æ–ª–∏–≥–æ–Ω, –æ—Ç–º–µ–Ω—è–µ–º –µ–≥–æ
                if (currentTool === 'polygon' && drawingPath && drawingPath.length > 0) {
                    // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ–ª–∏–≥–æ–Ω–∞
                    const tempElements = canvas.getObjects().filter(obj =>
                        obj.data && (obj.data.type === 'polygon-temp-line' || obj.data.type === 'polygon-line' || obj.data.type === 'polygon-point')
                    );
                    tempElements.forEach(element => canvas.remove(element));
                    drawingPath = [];
                    canvas.renderAll();
                    
                    // –°–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é
                    hideSizeMenu();
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
                    const status = document.getElementById('tcalc-status');
                    status.textContent = '–†–∏—Å–æ–≤–∞–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ. –ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–≥–æ –ø–æ–ª–∏–≥–æ–Ω–∞.';
                    return;
                }
                
                canvas.discardActiveObject();
                hideSizeMenu();
                canvas.renderAll();
            }
        });
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –º–µ–Ω—é —Ä–∞–∑–º–µ—Ä–æ–≤
        function showSizeMenu(boundary) {
            console.log('=== showSizeMenu –≤—ã–∑–≤–∞–Ω–∞ ===');
            console.log('boundary:', boundary);
            console.log('boundary.type:', boundary?.type);
            console.log('boundary.data:', boundary?.data);
            
            if (!boundary) return;
            // –î–ª—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
            if (boundary.type === 'rect') {
                console.log('–ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é –¥–ª—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞');
                currentEditingBoundary = boundary;
                updateSizeMenu(boundary);
                document.getElementById('tcalc-size-menu').style.display = 'block';
                return;
            }
            // –î–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞
            if (boundary.data && boundary.data.type === 'polygon-boundary') {
                console.log('–ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é –¥–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞');
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
                document.getElementById('tcalc-size-menu').style.display = 'block';
                // –ó–∞–ø–æ–ª–Ω—è–µ–º –ø–æ–ª—è –¥–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞
                let width = boundary.data.width || 0;
                let height = boundary.data.height || 0;
                const area = boundary.data.area || 0;
                const angle = boundary.data.angle || 0;
                const lengths = boundary.data.lengths || [];
                
                // –ï—Å–ª–∏ —Ä–∞–∑–º–µ—Ä—ã –Ω–µ –±—ã–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã, –≤—ã—á–∏—Å–ª—è–µ–º –∏—Ö –∑–∞–Ω–æ–≤–æ
                if (width === 0 || height === 0) {
                    const points = boundary.points || boundary._points;
                    if (points && points.length > 0) {
                        const dimensions = calculatePolygonDimensions(points);
                        width = dimensions.width;
                        height = dimensions.height;
                        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª–∏–≥–æ–Ω–∞
                        boundary.data.width = width;
                        boundary.data.height = height;
                    }
                }
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–ª–∏–Ω—É –∏ —à–∏—Ä–∏–Ω—É (–±–æ–ª—å—à–∏–π —Ä–∞–∑–º–µ—Ä = –¥–ª–∏–Ω–∞, –º–µ–Ω—å—à–∏–π = —à–∏—Ä–∏–Ω–∞)
                const length = Math.max(width, height);
                const widthValue = Math.min(width, height);
                
                document.getElementById('tcalc-length-input').value = length.toFixed(2);
                document.getElementById('tcalc-width-input').value = widthValue.toFixed(2);
                document.getElementById('tcalc-area-input').value = area.toFixed(2);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–ª–æ—â–∞–¥–∏ –ø–æ–ª–∏–≥–æ–Ω–∞ –∏ —É–≥–ª–∞
                document.getElementById('polygon-area-value').textContent = area.toFixed(2);
                document.getElementById('polygon-area-info').style.display = '';
                document.getElementById('polygon-stats').style.display = '';
                document.getElementById('polygon-current-line').style.display = 'none';
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–∏–º–µ—Ç—Ä –ø–æ–ª–∏–≥–æ–Ω–∞
                const perimeterElement = document.getElementById('polygon-perimeter');
                const perimeterValueElement = document.getElementById('polygon-perimeter-value');
                if (perimeterElement && perimeterValueElement && lengths.length > 0) {
                    const totalPerimeter = lengths.reduce((sum, length) => sum + parseFloat(length), 0);
                    perimeterValueElement.textContent = totalPerimeter.toFixed(2);
                    perimeterElement.style.display = '';
                }
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≥–æ–ª –Ω–∞–∫–ª–æ–Ω–∞ –ø–æ–ª–∏–≥–æ–Ω–∞
                const angleElement = document.getElementById('polygon-angle');
                const angleValueElement = document.getElementById('polygon-angle-value');
                if (angleElement && angleValueElement) {
                    angleValueElement.textContent = angle.toFixed(1);
                    angleElement.style.display = '';
                }
                
                console.log('–ú–µ–Ω—é –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∏–¥–∏–º—ã–º, –ø–ª–æ—â–∞–¥—å:', area, '–¥–ª–∏–Ω–∞:', length, '—à–∏—Ä–∏–Ω–∞:', widthValue, '—É–≥–æ–ª:', angle, '–ø–µ—Ä–∏–º–µ—Ç—Ä:', lengths);
                return;
            }
            console.log('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –æ–±—ä–µ–∫—Ç–∞:', boundary);
        }
        
        function updateSizeMenu(boundary) {
            if (!boundary || boundary.type !== 'rect') return;
            
            // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ —Ä–∞–∑–º–µ—Ä—ã –≤ –º–µ—Ç—Ä–∞—Ö
            const currentWidth = boundary.width * (boundary.scaleX || 1) / 10; // –≤ –º–µ—Ç—Ä–∞—Ö (1px = 100–º–º = 0.1–º)
            const currentHeight = boundary.height * (boundary.scaleY || 1) / 10; // –≤ –º–µ—Ç—Ä–∞—Ö
            
            // –í—ã—á–∏—Å–ª—è–µ–º –ø–ª–æ—â–∞–¥—å
            const area = currentWidth * currentHeight;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è –≤–≤–æ–¥–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –º–µ–Ω—é –≤–∏–¥–∏–º–æ
            const sizeMenu = document.getElementById('tcalc-size-menu');
            if (sizeMenu.style.display === 'block') {
                document.getElementById('tcalc-length-input').value = currentHeight.toFixed(2);
                document.getElementById('tcalc-width-input').value = currentWidth.toFixed(2);
                document.getElementById('tcalc-area-input').value = area.toFixed(2);
            }
        }
        
        function hideSizeMenu() {
            // –ù–µ —Å–∫—Ä—ã–≤–∞—Ç—å –º–µ–Ω—é, –µ—Å–ª–∏ —Ä–∏—Å—É–µ—Ç—Å—è –ø–æ–ª–∏–≥–æ–Ω –∏ –µ—Å—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ —Ç–æ—á–∫–∞
            if (currentTool === 'polygon' && drawingPath && drawingPath.length > 0) {
                return;
            }
            document.getElementById('tcalc-size-menu').style.display = 'none';
            currentEditingBoundary = null;
            // –û—á–∏—â–∞–µ–º –≤—ã–±–æ—Ä –Ω–∞ canvas
            canvas.discardActiveObject();
            canvas.renderAll();
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
            const status = document.getElementById('tcalc-status');
            if (currentTool === 'ruler') {
                status.textContent = '–ù–∞—Ä–∏—Å—É–π—Ç–µ –ø–ª–æ—â–∞–¥–∫—É –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø–ª–∏—Ç–∫–æ–π';
            } else if (currentTool === 'eraser') {
                status.textContent = '–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –æ–±—ä–µ–∫—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è';
            } else if (currentTool === 'polygon') {
                status.textContent = '–ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—á–µ–∫ –ø–æ–ª–∏–≥–æ–Ω–∞. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –∏–ª–∏ –∫–ª–∏–∫ –ø–æ –ø–µ—Ä–≤–æ–π —Ç–æ—á–∫–µ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.';
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –≤–Ω–µ –º–µ–Ω—é –¥–ª—è –µ–≥–æ —Å–∫—Ä—ã—Ç–∏—è
        document.addEventListener('click', function(e) {
            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ø—Ä–∞–≤—É—é –∫–Ω–æ–ø–∫—É –º—ã—à–∏
            if (e.button === 2) return;
            // –ù–µ —Å–∫—Ä—ã–≤–∞—Ç—å –º–µ–Ω—é, –µ—Å–ª–∏ –∏–¥—ë—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–∞
            if (currentTool === 'polygon' && drawingPath && drawingPath.length > 0) {
                return;
            }
            const sizeMenu = document.getElementById('tcalc-size-menu');
            if (sizeMenu.style.display === 'block' && !sizeMenu.contains(e.target)) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∫–ª–∏–∫–Ω—É–ª–∏ –ª–∏ –º—ã –Ω–∞ –ø–ª–æ—â–∞–¥–∫—É
                const clickedElement = e.target;
                if (clickedElement.tagName === 'CANVAS') {
                    // –ï—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ canvas, –ø—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω–∞—è –ø–ª–æ—â–∞–¥–∫–∞
                    if (!currentEditingBoundary) {
                        hideSizeMenu();
                    }
                } else if (!sizeMenu.contains(clickedElement)) {
                    hideSizeMenu();
                }
            }
        });
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –ø–æ–ª–µ–π –≤–≤–æ–¥–∞ —Ä–∞–∑–º–µ—Ä–æ–≤
        document.addEventListener('DOMContentLoaded', function() {
            const lengthInput = document.getElementById('tcalc-length-input');
            const widthInput = document.getElementById('tcalc-width-input');
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∑–Ω–∞—á–µ–Ω–∏–π –≤ –ø–æ–ª—è—Ö
            lengthInput.addEventListener('input', function() {
                if (currentEditingBoundary) {
                    updateBoundaryFromInputs();
                }
            });
            
            widthInput.addEventListener('input', function() {
                if (currentEditingBoundary) {
                    updateBoundaryFromInputs();
                }
            });
        });
        
        function updateBoundaryFromInputs() {
            if (!currentEditingBoundary) return;
            
            const lengthInput = document.getElementById('tcalc-length-input');
            const widthInput = document.getElementById('tcalc-width-input');
            const areaInput = document.getElementById('tcalc-area-input');
            
            const lengthMeters = parseFloat(lengthInput.value);
            const widthMeters = parseFloat(widthInput.value);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
            if (isNaN(lengthMeters) || isNaN(widthMeters) || lengthMeters <= 0 || widthMeters <= 0) {
                return; // –ù–µ –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö
            }
            
            // –í—ã—á–∏—Å–ª—è–µ–º –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–ª–æ—â–∞–¥—å
            const area = lengthMeters * widthMeters;
            areaInput.value = area.toFixed(2);
            
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –º–µ—Ç—Ä—ã –≤ –ø–∏–∫—Å–µ–ª–∏ (1–º = 10px)
            const lengthPixels = lengthMeters * 10;
            const widthPixels = widthMeters * 10;
            
            // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ —Å–µ—Ç–∫–µ
            const snappedLength = snapToGrid(lengthPixels);
            const snappedWidth = snapToGrid(widthPixels);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —É—á–∞—Å—Ç–∫–∞
            currentEditingBoundary.set({
                width: snappedWidth,
                height: snappedLength,
                scaleX: 1,
                scaleY: 1
            });
            
            // –û–±–Ω–æ–≤–ª—è–µ–º canvas
            canvas.renderAll();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            updateStatistics();
        }
        
        function applySizeToBoundary() {
            if (!currentEditingBoundary) return;
            
            // –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –ø–æ–ª–µ–π –≤–≤–æ–¥–∞
            const lengthInput = document.getElementById('tcalc-length-input');
            const widthInput = document.getElementById('tcalc-width-input');
            
            const lengthMeters = parseFloat(lengthInput.value);
            const widthMeters = parseFloat(widthInput.value);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
            if (isNaN(lengthMeters) || isNaN(widthMeters) || lengthMeters <= 0 || widthMeters <= 0) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã (–±–æ–ª—å—à–µ 0)');
                return;
            }
            
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –º–µ—Ç—Ä—ã –≤ –ø–∏–∫—Å–µ–ª–∏ (1–º = 10px)
            const lengthPixels = lengthMeters * 10;
            const widthPixels = widthMeters * 10;
            
            // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ —Å–µ—Ç–∫–µ
            const snappedLength = snapToGrid(lengthPixels);
            const snappedWidth = snapToGrid(widthPixels);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —É—á–∞—Å—Ç–∫–∞
            currentEditingBoundary.set({
                width: snappedWidth,
                height: snappedLength,
                scaleX: 1,
                scaleY: 1
            });
            
            // –û–±–Ω–æ–≤–ª—è–µ–º canvas
            canvas.renderAll();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            updateStatistics();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
            const status = document.getElementById('tcalc-status');
            status.textContent = `–†–∞–∑–º–µ—Ä—ã –ø–ª–æ—â–∞–¥–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: ${widthMeters.toFixed(2)}–º √ó ${lengthMeters.toFixed(2)}–º`;
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≤–≤–æ–¥–∞ –º–∞—Å—à—Ç–∞–±–∞
        function enableZoomInput() {
            const zoomLevelElement = document.getElementById('tcalc-zoom-level');
            if (!zoomLevelElement || zoomLevelElement.classList.contains('tcalc-zoom-input')) {
                return;
            }
            
            const currentZoomPercent = Math.round(currentZoom * 100);
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'tcalc-zoom-input';
            input.value = currentZoomPercent;
            input.style.width = zoomLevelElement.offsetWidth + 'px';
            input.placeholder = '100-700';
            
            // –ó–∞–º–µ–Ω—è–µ–º span –Ω–∞ input
            zoomLevelElement.parentNode.replaceChild(input, zoomLevelElement);
            input.id = 'tcalc-zoom-level';
            
            // –§–æ–∫—É—Å–∏—Ä—É–µ–º—Å—è –Ω–∞ –ø–æ–ª–µ –≤–≤–æ–¥–∞ –∏ –≤—ã–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç
            input.focus();
            input.select();
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è input
            input.addEventListener('blur', function() {
                applyZoomFromInput(input);
            });
            
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    applyZoomFromInput(input);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelZoomInput(input);
                }
            });
        }
        
        function applyZoomFromInput(input) {
            const value = parseInt(input.value);
            if (!isNaN(value) && value >= 100 && value <= 700) {
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—ã–π –º–∞—Å—à—Ç–∞–±
                const newZoom = value / 100;
                const oldZoom = currentZoom;
                currentZoom = newZoom;
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Å—à—Ç–∞–±
                canvas.setZoom(currentZoom);
                
                // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º viewport –Ω–∞ –∫—É—Ä—Å–æ—Ä–µ, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
                const vpt = canvas.viewportTransform;
                if (canvas.lastMouseEvent) {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —ç–∫—Ä–∞–Ω–∞ –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                    const mouseX = canvas.lastMouseEvent.clientX;
                    const mouseY = canvas.lastMouseEvent.clientY;
                    const canvasRect = canvas.wrapperEl.getBoundingClientRect();
                    const centerX = mouseX - canvasRect.left;
                    const centerY = mouseY - canvasRect.top;
                    const zoomRatio = currentZoom / oldZoom;
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é viewport –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –∫—É—Ä—Å–æ—Ä–µ
                    const newVpt4 = centerX - (centerX - vpt[4]) * zoomRatio;
                    const newVpt5 = centerY - (centerY - vpt[5]) * zoomRatio;
                    
                    vpt[4] = newVpt4;
                    vpt[5] = newVpt5;
                } else {
                    // –ï—Å–ª–∏ –∫—É—Ä—Å–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω, —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ canvas
                    vpt[4] = 0;
                    vpt[5] = 0;
                }
                
                canvas.setViewportTransform(vpt);
                
                // –í–∫–ª—é—á–∞–µ–º/–≤—ã–∫–ª—é—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
                if (currentZoom > 1) {
                    enablePanning();
                } else {
                    disablePanning();
                }
                
                canvas.renderAll();
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º span
                restoreZoomSpan(input, value + '%');
            } else {
                // –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –º–∞—Å—à—Ç–∞–±
                restoreZoomSpan(input, Math.round(currentZoom * 100) + '%');
            }
        }
        
        function cancelZoomInput(input) {
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –º–∞—Å—à—Ç–∞–±
            restoreZoomSpan(input, Math.round(currentZoom * 100) + '%');
        }
        
        function restoreZoomSpan(input, text) {
            const span = document.createElement('span');
            span.className = 'tcalc-zoom-level';
            span.id = 'tcalc-zoom-level';
            span.textContent = text;
            span.onclick = enableZoomInput;
            span.title = '–ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –≤–≤–æ–¥–∞ –º–∞—Å—à—Ç–∞–±–∞ (100-700%)';
            
            // –ó–∞–º–µ–Ω—è–µ–º input –Ω–∞ span
            input.parentNode.replaceChild(span, input);
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è –º–µ–Ω—é —Ä–∞–∑–º–µ—Ä–æ–≤
        function initSizeMenuDragging() {
            const sizeMenu = document.getElementById('tcalc-size-menu');
            if (!sizeMenu) return;
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ mousedown –¥–ª—è –Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
            sizeMenu.addEventListener('mousedown', function(e) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª–∏–∫ –Ω–µ –Ω–∞ –∫–Ω–æ–ø–∫–∞—Ö –∏–ª–∏ –ø–æ–ª—è—Ö –≤–≤–æ–¥–∞
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'H4') {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                
                isSizeMenuDragging = true;
                sizeMenuDragStart = { x: e.clientX, y: e.clientY };
                sizeMenuOriginalPosition = { 
                    top: parseInt(sizeMenu.style.top) || 50, 
                    right: parseInt(sizeMenu.style.right) || 10 
                };
                
                // –ò–∑–º–µ–Ω—è–µ–º –∫—É—Ä—Å–æ—Ä
                sizeMenu.style.cursor = 'grabbing';
                
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
                document.addEventListener('mousemove', onSizeMenuMouseMove);
                document.addEventListener('mouseup', onSizeMenuMouseUp);
            });
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ mousedown –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
            const resizeHandle = sizeMenu.querySelector('.tcalc-size-menu-resize-handle');
            if (resizeHandle) {
                resizeHandle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isSizeMenuResizing = true;
                    sizeMenuResizeStart = { x: e.clientX, y: e.clientY };
                    sizeMenuOriginalSize = { 
                        width: sizeMenu.offsetWidth, 
                        height: sizeMenu.offsetHeight 
                    };
                    
                    // –ò–∑–º–µ–Ω—è–µ–º –∫—É—Ä—Å–æ—Ä
                    sizeMenu.style.cursor = 'nw-resize';
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
                    document.addEventListener('mousemove', onSizeMenuResizeMove);
                    document.addEventListener('mouseup', onSizeMenuMouseUp);
                });
            }
        }
        
        function onSizeMenuMouseMove(e) {
            if (!isSizeMenuDragging || !sizeMenuDragStart) return;
            
            const sizeMenu = document.getElementById('tcalc-size-menu');
            if (!sizeMenu) return;
            
            const deltaX = e.clientX - sizeMenuDragStart.x;
            const deltaY = e.clientY - sizeMenuDragStart.y;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const newRight = sizeMenuOriginalPosition.right - deltaX;
            const newTop = sizeMenuOriginalPosition.top + deltaY;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö canvas
            const canvasContainer = document.querySelector('.tcalc-canvas-container');
            const menuRect = sizeMenu.getBoundingClientRect();
            const containerRect = canvasContainer.getBoundingClientRect();
            
            const maxRight = containerRect.width - menuRect.width - 10;
            const maxTop = containerRect.height - menuRect.height - 10;
            
            const clampedRight = Math.max(10, Math.min(maxRight, newRight));
            const clampedTop = Math.max(10, Math.min(maxTop, newTop));
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            sizeMenu.style.right = clampedRight + 'px';
            sizeMenu.style.top = clampedTop + 'px';
        }
        
        function onSizeMenuMouseUp(e) {
            if (!isSizeMenuDragging && !isSizeMenuResizing) return;
            
            const sizeMenu = document.getElementById('tcalc-size-menu');
            if (sizeMenu) {
                if (isSizeMenuDragging) {
                    sizeMenu.style.cursor = 'move';
                } else if (isSizeMenuResizing) {
                    sizeMenu.style.cursor = 'move';
                }
            }
            
            isSizeMenuDragging = false;
            isSizeMenuResizing = false;
            sizeMenuDragStart = null;
            sizeMenuOriginalPosition = null;
            sizeMenuResizeStart = null;
            sizeMenuOriginalSize = null;
            
            // –£–¥–∞–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            document.removeEventListener('mousemove', onSizeMenuMouseMove);
            document.removeEventListener('mousemove', onSizeMenuResizeMove);
            document.removeEventListener('mouseup', onSizeMenuMouseUp);
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–º —É–≥–ª–∞ –ø–æ–≤–æ—Ä–æ—Ç–∞
        function showRotationIndicator(boundary) {
            const indicator = document.getElementById('tcalc-rotation-indicator');
            if (indicator) {
                indicator.style.display = 'block';
                updateRotationIndicator(boundary);
            }
        }
        
        function hideRotationIndicator() {
            const indicator = document.getElementById('tcalc-rotation-indicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }
        
        function updateRotationIndicator(boundary) {
            const angleElement = document.getElementById('tcalc-rotation-angle');
            if (angleElement && boundary) {
                const angle = boundary.angle || 0;
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —É–≥–ª—ã –¥–ª—è –Ω–∞–∫–ª–æ–Ω–∞ –≤–ª–µ–≤–æ
                angleElement.textContent = Math.round(angle) + '¬∞';
            }
        }
        
        function showCursorAngle(boundary, event) {
            const cursorAngle = document.getElementById('tcalc-cursor-angle');
            const cursorAngleValue = document.getElementById('tcalc-cursor-angle-value');
            
            if (cursorAngle && cursorAngleValue && boundary) {
                const angle = boundary.angle || 0;
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —É–≥–ª—ã –¥–ª—è –Ω–∞–∫–ª–æ–Ω–∞ –≤–ª–µ–≤–æ
                cursorAngleValue.textContent = Math.round(angle) + '¬∞';
                
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º —Ä—è–¥–æ–º —Å –∫—É—Ä—Å–æ—Ä–æ–º
                cursorAngle.style.left = (event.clientX + 15) + 'px';
                cursorAngle.style.top = (event.clientY - 25) + 'px';
                cursorAngle.style.display = 'block';
            }
        }
        
        function hideCursorAngle() {
            const cursorAngle = document.getElementById('tcalc-cursor-angle');
            if (cursorAngle) {
                cursorAngle.style.display = 'none';
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–π –ø–ª–∏—Ç–∫–∏
        function createRotatedTile(position, width, height, tileType, bounds) {
            const gradient = new fabric.Gradient({
                type: 'linear',
                coords: {
                    x1: 0,
                    y1: 0,
                    x2: width,
                    y2: height
                },
                colorStops: [
                    { offset: 0, color: '#ffffff' },
                    { offset: 1, color: '#cccccc' }
                ]
            });
            
            const tile = new fabric.Rect({
                left: position.x,
                top: position.y,
                width: width,
                height: height,
                fill: gradient,
                stroke: '#d2b48c',
                strokeWidth: 0.05,
                selectable: false,
                angle: bounds.angle, // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ø–ª–∏—Ç–∫—É –Ω–∞ —Ç–æ—Ç –∂–µ —É–≥–æ–ª
                data: { 
                    type: 'tile',
                    tileType: tileType,
                    orientation: 'rotated'
                }
            });
            
            return tile;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π –ø–ª–æ—â–∞–¥–∫–∏
        function deleteCurrentBoundary() {
            if (!currentEditingBoundary) return;
            
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç—É –ø–ª–æ—â–∞–¥–∫—É?')) {
                // –£–¥–∞–ª—è–µ–º –≤—Å–µ –ø–ª–∏—Ç–∫–∏ –≤–Ω—É—Ç—Ä–∏ —É—á–∞—Å—Ç–∫–∞
                const boundaryBounds = getBoundaryBounds(currentEditingBoundary);
                const tiles = canvas.getObjects().filter(obj => 
                    obj.data && obj.data.type === 'tile' && 
                    isTileInBoundary(obj, boundaryBounds)
                );
                tiles.forEach(tile => canvas.remove(tile));
                
                // –£–¥–∞–ª—è–µ–º —Å–∞–º —É—á–∞—Å—Ç–æ–∫
                canvas.remove(currentEditingBoundary);
                
                // –°–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é –∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
                hideSizeMenu();
                hideRotationIndicator();
                
                // –û—á–∏—â–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º—ã–π —É—á–∞—Å—Ç–æ–∫
                currentEditingBoundary = null;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                canvas.renderAll();
                updateResults();
                updateStatistics();
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
                const status = document.getElementById('tcalc-status');
                status.textContent = '–ü–ª–æ—â–∞–¥–∫–∞ —É–¥–∞–ª–µ–Ω–∞';
            }
        }
        
        function onSizeMenuResizeMove(e) {
            if (!isSizeMenuResizing || !sizeMenuResizeStart) return;
            
            const sizeMenu = document.getElementById('tcalc-size-menu');
            if (!sizeMenu) return;
            
            const deltaX = e.clientX - sizeMenuResizeStart.x;
            const deltaY = e.clientY - sizeMenuResizeStart.y;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—ã–µ —Ä–∞–∑–º–µ—Ä—ã (—É–º–µ–Ω—å—à–∞–µ–º —à–∏—Ä–∏–Ω—É –∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏ –≤–ª–µ–≤–æ-–≤–≤–µ—Ä—Ö)
            const newWidth = sizeMenuOriginalSize.width - deltaX;
            const newHeight = sizeMenuOriginalSize.height + deltaY;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã
            const clampedWidth = Math.max(200, Math.min(300, newWidth));
            const clampedHeight = Math.max(180, Math.min(400, newHeight));
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—ã–µ —Ä–∞–∑–º–µ—Ä—ã
            sizeMenu.style.width = clampedWidth + 'px';
            sizeMenu.style.height = clampedHeight + 'px';
        }

        function calculatePolygonArea(points) {
            let area = 0;
            const n = points.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += (points[i].x * points[j].y) - (points[j].x * points[i].y);
            }
            // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ñ–æ—Ä–º—É–ª–∞: 1px = 0.1–º, –∑–Ω–∞—á–∏—Ç 1px¬≤ = 0.01–º¬≤
            // –ù–æ –Ω—É–∂–Ω–æ –¥–µ–ª–∏—Ç—å –Ω–∞ 2, —Ç–∞–∫ –∫–∞–∫ —Ñ–æ—Ä–º—É–ª–∞ –ì–∞—É—Å—Å–∞ –¥–∞—ë—Ç —É–¥–≤–æ–µ–Ω–Ω—É—é –ø–ª–æ—â–∞–¥—å
            return Math.abs(area) / 200; // –≤ –º¬≤
        }
        
        function calculatePolygonDimensions(points) {
            if (!points || points.length === 0) return { width: 0, height: 0 };
            
            let minX = points[0].x;
            let maxX = points[0].x;
            let minY = points[0].y;
            let maxY = points[0].y;
            
            for (let i = 1; i < points.length; i++) {
                minX = Math.min(minX, points[i].x);
                maxX = Math.max(maxX, points[i].x);
                minY = Math.min(minY, points[i].y);
                maxY = Math.max(maxY, points[i].y);
            }
            
            const width = (maxX - minX) / 10; // –≤ –º–µ—Ç—Ä–∞—Ö (1px = 0.1–º)
            const height = (maxY - minY) / 10; // –≤ –º–µ—Ç—Ä–∞—Ö (1px = 0.1–º)
            
            return { width, height };
        }
        
        function calculatePolygonLengths(points) {
            if (!points || points.length < 2) return [];
            
            const lengths = [];
            for (let i = 0; i < points.length; i++) {
                const nextIndex = (i + 1) % points.length;
                const dx = points[nextIndex].x - points[i].x;
                const dy = points[nextIndex].y - points[i].y;
                const length = Math.sqrt(dx * dx + dy * dy) / 10; // –≤ –º–µ—Ç—Ä–∞—Ö
                lengths.push(length.toFixed(1));
            }
            
            return lengths;
        }

        function finalizePolygon() {
            if (!drawingPath || drawingPath.length < 3) return;
            
            // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã (lines, points, temp-line)
            const tempElements = canvas.getObjects().filter(obj =>
                obj.data && (obj.data.type === 'polygon-temp-line' || obj.data.type === 'polygon-line' || obj.data.type === 'polygon-point')
            );
            tempElements.forEach(element => canvas.remove(element));
            
            // –°–æ–∑–¥–∞—ë–º –ø–æ–ª–∏–≥–æ–Ω –∫–∞–∫ fabric.Polygon –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –ø–ª–æ—â–∞–¥–∏
            const polygonPoints = drawingPath.map(p => ({ x: p.x, y: p.y }));
            const area = calculatePolygonArea(polygonPoints);
            const dimensions = calculatePolygonDimensions(polygonPoints);
            const angle = calculatePolygonAngle(polygonPoints);
            
            console.log('–°–æ–∑–¥–∞—ë–º –ø–æ–ª–∏–≥–æ–Ω —Å —Ä–∞–∑–º–µ—Ä–∞–º–∏:', dimensions, '–ø–ª–æ—â–∞–¥—å:', area, '—É–≥–æ–ª:', angle);
            
            // –°–æ–∑–¥–∞—ë–º –ø–æ–ª–∏–≥–æ–Ω –≤ —Å—Ç–∏–ª–µ IrriSketch
            const polygon = new fabric.Polygon(polygonPoints, {
                fill: 'rgba(34, 139, 34, 0.2)', // –°–≤–µ—Ç–ª–æ-–∑–µ–ª–µ–Ω—ã–π —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
                stroke: '#228B22', // –¢–µ–º–Ω–æ-–∑–µ–ª–µ–Ω—ã–π
                strokeWidth: 2,
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                lockRotation: false,
                lockScaling: false,
                lockMovementX: false,
                lockMovementY: false,
                data: {
                    type: 'polygon-boundary',
                    area: area,
                    width: dimensions.width,
                    height: dimensions.height,
                    angle: angle,
                    points: polygonPoints,
                    lengths: calculatePolygonLengths(polygonPoints)
                }
            });
            
            // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–∏–≥–æ–Ω
            canvas.add(polygon);
            canvas.setActiveObject(polygon);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
            currentEditingBoundary = polygon;
            showSizeMenu(polygon);
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
            drawingPath = [];
            canvas.renderAll();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            updateStatistics();
        }
    </script>
</body>
</html> 
